[{"model": "blog.note", "pk": 1, "fields": {"title": "redis的一些记录", "desc": "暂无简介", "content": "安装redis\r\nwindows下载 or pip install redis\r\ncd redis路径\r\nredis-server.exe redis.windows.conf 启动redis命令\r\n如果失败Nov 09:30:50.919 # Creating Server TCP listening socket 127.0.0.1:6379: bind: No error\r\n输入redis-cli.exe\r\n输入shutdown 结束\r\n输入 exit 退出\r\nredis-server.exe redis.windows.conf 重新输入启动redis\r\n\r\n\r\nredis.windows.conf是针对于cmd命令启动redis的配置参数，\r\nredis.windows-server.conf是针对于服务中启动redis的配置参数。\r\n\r\n重新连接\r\nredis-cli -h 127.0.0.1 -p 6379 shutdown\r\n返回NOAUTH Authentication required 输入密码 auth 密码\r\n查看密码\r\nredis-cli.exe\r\nconfig get requirepass\r\nauth 123456\r\n修改密码\r\n#requirepass foobared，改成requirepass 密码 386行\r\n接着按住shift后右键进入该目录下的命令行，执行redis-server.exe 你改的配置的文件名比如redis.windows.conf\r\n例如requirepass 123456\r\n\r\n密码修改未生效,显示\"\"\r\n问题在于我们启动redis服务时是直接在其安装目录中双击redis-server.exe启动的，\r\n这样启动的结果是，配置文件不会指定，此时redis并不会自动使用安装目录下的redis.windows.conf（或redis.conf）文件\r\n红线框住的的提示说的很明确“ Warning: no config file specified”没有指定配置文件\r\n法1：实际上我们直接在安装目录中启动redis服务时错误的，\r\n正确的方式是打开“运行”，键入“cmd”切到安装目录后输出redis-server.exe redis.windows.conf，回车，就可以了。\r\n法2:在redis安装目录下新建文件startup.bat后，右击“编辑”，或者先用记事本建立该文件，\r\n再把扩展名改一下，文件里面写上：redis-server.exe redis.windows.conf。\r\n以后再运行就直接运行这个文件，不要再直接运行redis-server.exe了，就可以了。\r\n我是修改windowsservice服务右击启动\r\n\r\n注册为服务（一般安装时候勾选就好了）\r\n把命令行窗口关闭 redis也会被关闭，所以我们需要把它注册成服务成功后就能在服务管理中找到\r\n如果安装后默认已经添加了这个服务项，那就不能再次添加，你可以右键查看属性\r\n命令是：redis-server.exe --service-install redis.windows.conf\r\n\r\n或者\r\nnet stop redis 停止redis\r\nnet start redis 启动redis\r\n\r\n客户端连接服务器\r\nredis-cli.exe -p 6379\r\nredis-cli -h ip -p 端口 -a 密码\r\n\r\n#切换数据库 默认16个（0-15）默认进入db0\r\nselect number\r\n\r\n#查看redis整体情况\r\ninfo\r\n\r\n\r\n命令：可参考https://blog.csdn.net/weixin_44706011/article/details/103038944\r\n字符串\r\n查找所有符合给定模式的key\r\nKEYS *\r\n设置指定key的值\r\nset key名称 值 nx ex （nx代表不存在是才存储，exexpire过期时间 单位s）\r\n获取指定key的值\r\nget key名称\r\n返回key长度\r\nstrlen key\r\n#key切片\r\ngetrange key start stop\r\n#从索引开始用value替换原内容\r\nsetrange key index value\r\n返回键类型\r\ntype key\r\n返回存在\r\nexists key\r\n删除key\r\ndel key\r\n#重命名\r\nrename key newkey\r\n批量添加key value\r\nmset k1 v1 k2 v2 k3 v3..\r\n批量获取key\r\nmget k1 k2 k3...\r\n#清除当前数据库\r\nflushdb\r\n#清除所有数据库\r\nflushall\r\n\r\n数值操作（在redis看作string）\r\nincrby key 步长 （增加步长例如1+5=6）\r\ndecrby key 步长 （减少。。。）\r\nincr key (+1操作）\r\ndecr key (-1）\r\nincrbyfloat key step (例如10 -6.6=8.4）\r\n\r\n查看过期时间\r\nttl key 返回-1无过期 0剩余过期 -2key不存在\r\nexpire key 5 设置过期5s\r\npexpire key 5 设置过期5ms\r\npersist key 删除过期时间 0/1 1为成功\r\n\r\n列表\r\nlpush key v1 v2 ... 从列表头压入数据 返回list最新长度\r\nrpush 从尾\r\nlrange key start stop 查看列表\r\nllen key 获取长度\r\nrpoplpush src dst 从src尾部弹出1个元素，压入到列表dst头部 返回被弹出的元素\r\nlinsert key after|before value newvalue 在列表指定元素前后插入元素，返回列表长度，如果没有找到pivot,返回-1,如果key不存在或空列表，返回0\r\nlpop key 从头弹出一个元素\r\nrpop key\r\nblpop key timeout 从列表头，阻塞弹出一个元素，列表为空或不存在阻塞 timeout=0时永久阻塞直到有数据可弹出，如果多个客户端阻塞在同一列表，先到先服务\r\nbrpop key timeout\r\nlrem key count value 删除指定元素（count>0从头开始，count个；count<0从尾开始，count个；count=0，删除所有=value;返回被删除的数量\r\nltrim key start stop 保留范围内的元素 l'trim weibo:comments 0 499保存最后500\r\nlset key index newvalue 设置指定索引的值\r\n\r\n位图\r\nsetbit key offset value #offset偏移量从0开始 value0or1\r\ngetbit key offset 获取某一位的值\r\nbitcount key start end 统计键对应值有多少1\r\n\r\n\r\n#redis哨兵", "note_img": "uploads/blog/blog.jpeg", "create_time": "2022-07-22T16:49:14.809", "update_time": "2022-07-22T21:14:39.710", "click_num": 14, "love_num": 0, "user": 1}}, {"model": "blog.note", "pk": 2, "fields": {"title": "1062报错", "desc": "暂无简介", "content": "注册功能post后报错1062\r\n原因重复插入（唯一索引并发写入问题）表唯一约束的字段重复插入，例如username并发注册时会报\r\n解决方案使用try：。。。except Exception as e:抛出异常", "note_img": "uploads/blog/2022/07/23/blog_14.jpeg", "create_time": "2022-07-22T16:56:47.576", "update_time": "2022-07-23T16:58:39.314", "click_num": 3, "love_num": 0, "user": 1}}, {"model": "blog.note", "pk": 3, "fields": {"title": "pycharm快捷操作", "desc": "暂无简介", "content": "pycharm快捷键及一些常用设置\r\n\r\n1、编辑(Editing)\r\n\r\nCtrl + Space 基本的代码完成(类、方法、属性)\r\n\r\nCtrl + Alt + Space 快速导入任意类\r\n\r\nCtrl + Shift + Enter 语句完成\r\n\r\nCtrl + P 参数信息(在方法中调用参数)\r\n\r\nCtrl + Q 快速查看文档\r\n\r\nShift + F1 外部文档\r\n\r\nCtrl + 鼠标 简介\r\n\r\nCtrl + F1 显示错误描述或警告信息\r\n\r\nAlt + Insert 自动生成代码\r\n\r\nCtrl + O 重新方法\r\n\r\nCtrl + Alt + T 选中\r\n\r\nCtrl + / 行注释\r\n\r\nCtrl + Shift + / 块注释\r\n\r\nCtrl + W 选中增加的代码块\r\n\r\nCtrl + Shift + W 回到之前状态\r\n\r\nCtrl + Shift + ]/[ 选定代码块结束、开始\r\n\r\nAlt + Enter 快速修正\r\n\r\nCtrl + Alt + L 代码格式化\r\n\r\nCtrl + Alt + O 优化导入\r\n\r\nCtrl + Alt + I 自动缩进\r\n\r\nTab / Shift + Tab 缩进、不缩进当前行\r\n\r\nCtrl+X/Shift+Delete 剪切当前行或选定的代码块到剪贴板\r\n\r\nCtrl+C/Ctrl+Insert 复制当前行或选定的代码块到剪贴板\r\n\r\nCtrl+V/Shift+Insert 从剪贴板粘贴\r\n\r\nCtrl + Shift + V 从最近的缓冲区粘贴\r\n\r\nCtrl + D 复制选定的区域或行\r\n\r\nCtrl + Y 删除选定的行\r\n\r\nCtrl + Shift + J 添加智能线\r\n\r\nCtrl + Enter 智能线切割\r\n\r\nShift + Enter 另起一行\r\n\r\nCtrl + Shift + U 在选定的区域或代码块间切换\r\n\r\nCtrl + Delete 删除到字符结束\r\n\r\nCtrl + Backspace 删除到字符开始\r\n\r\nCtrl + Numpad+/- 展开折叠代码块\r\n\r\nCtrl + Numpad+ 全部展开\r\n\r\nCtrl + Numpad- 全部折叠\r\n\r\nCtrl + F4 关闭运行的选项卡\r\n\r\n2、查找/替换(Search/Replace)\r\n\r\nF3 下一个\r\n\r\nShift + F3 前一个\r\n\r\nCtrl + R 替换\r\n\r\nCtrl + Shift + F 全局查找\r\n\r\nCtrl + Shift + R 全局替换\r\n\r\n3、运行(Running)\r\n\r\nAlt + Shift + F10 运行模式配置\r\n\r\nAlt + Shift + F9 调试模式配置\r\n\r\nShift + F10 运行\r\n\r\nShift + F9 调试\r\n\r\nCtrl + Shift + F10 运行编辑器配置\r\n\r\nCtrl + Alt + R 运行manage.py任务\r\n\r\n4、调试(Debugging)\r\n\r\nF8 跳过\r\n\r\nF7 进入\r\n\r\nShift + F8 退出\r\n\r\nAlt + F9 运行游标\r\n\r\nAlt + F8 验证表达式\r\n\r\nCtrl + Alt + F8 快速验证表达式\r\n\r\nF9 恢复程序\r\n\r\nCtrl + F8 断点开关\r\n\r\nCtrl + Shift + F8 查看断点\r\n\r\n5、导航(Navigation)\r\n\r\nCtrl + N 跳转到类\r\n\r\nCtrl + Shift + N 跳转到符号\r\n\r\nAlt + Right/Left 跳转到下一个、前一个编辑的选项卡\r\n\r\nF12 回到先前的工具窗口\r\n\r\nEsc 从工具窗口回到编辑窗口\r\n\r\nShift + Esc 隐藏运行的、最近运行的窗口\r\n\r\nCtrl + Shift + F4 关闭主动运行的选项卡\r\n\r\nCtrl + G 查看当前行号、字符号\r\n\r\nCtrl + E 当前文件弹出\r\n\r\nCtrl+Alt+Left/Right 后退、前进\r\n\r\nCtrl+Shift+Backspace 导航到最近编辑区域\r\n\r\nAlt + F1 查找当前文件或标识\r\n\r\nCtrl+B / Ctrl+Click 跳转到声明\r\n\r\nCtrl + Alt + B 跳转到实现\r\n\r\nCtrl + Shift + I查看快速定义\r\n\r\nCtrl + Shift + B跳转到类型声明\r\n\r\nCtrl + U跳转到父方法、父类\r\n\r\nAlt + Up/Down跳转到上一个、下一个方法\r\n\r\nCtrl + ]/[跳转到代码块结束、开始\r\n\r\nCtrl + F12弹出文件结构\r\n\r\nCtrl + H类型层次结构\r\n\r\nCtrl + Shift + H方法层次结构\r\n\r\nCtrl + Alt + H调用层次结构\r\n\r\nF2 / Shift + F2下一条、前一条高亮的错误\r\n\r\nF4 / Ctrl + Enter编辑资源、查看资源\r\n\r\nAlt + Home显示导航条F11书签开关\r\n\r\nCtrl + Shift + F11书签助记开关\r\n\r\nCtrl + #[0-9]跳转到标识的书签\r\n\r\nShift + F11显示书签\r\n\r\n6、搜索相关(Usage Search)\r\n\r\nAlt + F7/Ctrl + F7文件中查询用法\r\n\r\nCtrl + Shift + F7文件中用法高亮显示\r\n\r\nCtrl + Alt + F7显示用法\r\n\r\n7、重构(Refactoring)\r\n\r\nF5复制F6剪切\r\n\r\nAlt + Delete安全删除\r\n\r\nShift + F6重命名\r\n\r\nCtrl + F6更改签名\r\n\r\nCtrl + Alt + N内联\r\n\r\nCtrl + Alt + M提取方法\r\n\r\nCtrl + Alt + V提取属性\r\n\r\nCtrl + Alt + F提取字段\r\n\r\nCtrl + Alt + C提取常量\r\n\r\nCtrl + Alt + P提取参数\r\n\r\n8、控制VCS/Local History\r\n\r\nCtrl + K提交项目\r\n\r\nCtrl + T更新项目\r\n\r\nAlt + Shift + C查看最近的变化\r\n\r\nAlt + BackQuote(’)VCS快速弹出\r\n\r\n9、模版(Live Templates)\r\n\r\nCtrl + Alt + J当前行使用模版\r\n\r\nCtrl +Ｊ插入模版\r\n\r\n10、基本(General)\r\n\r\nAlt + #[0-9]打开相应的工具窗口\r\n\r\nCtrl + Alt + Y同步\r\n\r\nCtrl + Shift + F12最大化编辑开关\r\n\r\nAlt + Shift + F添加到最喜欢\r\n\r\nAlt + Shift + I根据配置检查当前文件\r\n\r\nCtrl + BackQuote(’)快速切换当前计划\r\n\r\nCtrl + Alt + S　打开设置页\r\n\r\nCtrl + Shift + A查找编辑器里所有的动作\r\n\r\nCtrl + Tab在窗口间进行切换\r\n\r\n一些常用设置：\r\n\r\npycharm默认是自动保存的，习惯自己按ctrl + s 的可以进行如下设置：\r\n\r\nfile -> Setting -> General -> Synchronization -> Save files on frame deactivation 和 Save files automatically if application is idle for .. sec 的勾去掉\r\n\r\nfile ->Setting -> Editor -> Editor Tabs -> Mark modified tabs with asterisk 打上勾\r\n\r\nAlt + Enter: 自动添加包\r\n\r\n对于常用的快捷键，可以设置为visual studio(eclipse...)一样的：\r\n\r\n-> Setting -> Keymap -> Keymaps -> vuisual studio -> Apply\r\n\r\nPycharm中默认是不能用Ctrl+滚轮改变字体大小的，可以在file -> Setting ->Editor-〉Mouse中设置\r\n\r\n要设置Pycharm的字体，要先在file -> Setting ->Editor-〉Editor中选择一种风格并保存，然后才可以改变\r\n\r\n在setting中搜索theme可以改变主题，所有配色统一改变\r\n\r\n补充:\r\n\r\n1、编辑(Editing)\r\n\r\nCtrl + Space    基本的代码完成(类、方法、属性)\r\n\r\nCtrl + Alt + Space  快速导入任意类\r\n\r\nCtrl + Shift + Enter    语句完成\r\n\r\nCtrl + P    参数信息(在方法中调用参数)\r\n\r\nCtrl + Q    快速查看文档\r\n\r\nShift + F1    外部文档\r\n\r\nCtrl + Shift + Z --> Redo 重做\r\n\r\nCtrl + 鼠标    简介\r\n\r\nCtrl + F1    显示错误描述或警告信息\r\n\r\nAlt + Insert    自动生成代码\r\n\r\nCtrl + O    重新方法\r\n\r\nCtrl + Alt + T    选中\r\n\r\nCtrl + /    行注释\r\n\r\nCtrl + Shift + /    块注释\r\n\r\nCtrl + W    选中增加的代码块\r\n\r\nCtrl + Shift + W    回到之前状态\r\n\r\nCtrl + Shift + ]/[     选定代码块结束、开始\r\n\r\nAlt + Enter    快速修正\r\n\r\nCtrl + Alt + L     代码格式化\r\n\r\nCtrl + Alt + O    优化导入\r\n\r\nCtrl + Alt + I    自动缩进\r\n\r\nTab / Shift + Tab  缩进、不缩进当前行\r\n\r\nCtrl+X/Shift+Delete    剪切当前行或选定的代码块到剪贴板\r\n\r\nCtrl+C/Ctrl+Insert    复制当前行或选定的代码块到剪贴板\r\n\r\nCtrl+V/Shift+Insert    从剪贴板粘贴\r\n\r\nCtrl + Shift + V    从最近的缓冲区粘贴\r\n\r\nCtrl + D  复制选定的区域或行\r\n\r\nCtrl + Y    删除选定的行\r\n\r\nCtrl + Shift + J  添加智能线\r\n\r\nCtrl + Enter   智能线切割\r\n\r\nShift + Enter    另起一行\r\n\r\nCtrl + Shift + U  在选定的区域或代码块间切换\r\n\r\nCtrl + Delete   删除到字符结束\r\n\r\nCtrl + Backspace   删除到字符开始\r\n\r\nCtrl + Numpad+/-   展开/折叠代码块(当前位置的：函数，注释等)\r\n\r\nCtrl + shift + Numpad+/-   展开/折叠所有代码块\r\n\r\nCtrl + F4   关闭运行的选项卡\r\n\r\n2、查找/替换(Search/Replace)\r\n\r\nF3   下一个\r\n\r\nShift + F3   前一个\r\n\r\nCtrl + R   替换\r\n\r\nCtrl + Shift + F   全局查找\r\n\r\nCtrl + Shift + R   全局替换\r\n\r\n3、运行(Running)\r\n\r\nAlt + Shift + F10   运行模式配置\r\n\r\nAlt + Shift + F9    调试模式配置\r\n\r\nShift + F10    运行\r\n\r\nShift + F9   调试\r\n\r\nCtrl + Shift + F10   运行编辑器配置\r\n\r\nCtrl + Alt + R   运行manage.py任务\r\n\r\n4、调试(Debugging)\r\n\r\nF8   跳过\r\n\r\nF7   进入\r\n\r\nShift + F8   退出\r\n\r\nAlt + F9    运行游标\r\n\r\nAlt + F8    验证表达式\r\n\r\nCtrl + Alt + F8   快速验证表达式\r\n\r\nF9    恢复程序\r\n\r\nCtrl + F8   断点开关\r\n\r\nCtrl + Shift + F8   查看断点\r\n\r\n5、导航(Navigation)\r\n\r\nCtrl + N    跳转到类\r\n\r\nCtrl + Shift + N    跳转到符号\r\n\r\nAlt + Right/Left    跳转到下一个、前一个编辑的选项卡\r\n\r\nF12    回到先前的工具窗口\r\n\r\nEsc    从工具窗口回到编辑窗口\r\n\r\nShift + Esc   隐藏运行的、最近运行的窗口\r\n\r\nCtrl + Shift + F4   关闭主动运行的选项卡\r\n\r\nCtrl + G    查看当前行号、字符号\r\n\r\nCtrl + E   当前文件弹出\r\n\r\nCtrl+Alt+Left/Right   后退、前进\r\n\r\nCtrl+Shift+Backspace    导航到最近编辑区域\r\n\r\nAlt + F1   查找当前文件或标识\r\n\r\nCtrl+B / Ctrl+Click    跳转到声明\r\n\r\nCtrl + Alt + B    跳转到实现\r\n\r\nCtrl + Shift + I查看快速定义\r\n\r\nCtrl + Shift + B跳转到类型声明\r\n\r\nCtrl + U跳转到父方法、父类\r\n\r\nAlt + Up/Down跳转到上一个、下一个方法\r\n\r\nCtrl + ]/[跳转到代码块结束、开始\r\n\r\nCtrl + F12弹出文件结构\r\n\r\nCtrl + H类型层次结构\r\n\r\nCtrl + Shift + H方法层次结构\r\n\r\nCtrl + Alt + H调用层次结构\r\n\r\nF2 / Shift + F2下一条、前一条高亮的错误\r\n\r\nF4 / Ctrl + Enter编辑资源、查看资源\r\n\r\nAlt + Home显示导航条F11书签开关\r\n\r\nCtrl + Shift + F11书签助记开关\r\n\r\nCtrl + #[0-9]跳转到标识的书签\r\n\r\nShift + F11显示书签\r\n\r\n6、搜索相关(Usage Search)\r\n\r\nAlt + F7/Ctrl + F7文件中查询用法\r\n\r\nCtrl + Shift + F7文件中用法高亮显示\r\n\r\nCtrl + Alt + F7显示用法\r\n\r\n7、重构(Refactoring)\r\n\r\nF5复制F6剪切\r\n\r\nAlt + Delete安全删除\r\n\r\nShift + F6重命名\r\n\r\nCtrl + F6更改签名\r\n\r\nCtrl + Alt + N内联\r\n\r\nCtrl + Alt + M提取方法\r\n\r\nCtrl + Alt + V提取属性\r\n\r\nCtrl + Alt + F提取字段\r\n\r\nCtrl + Alt + C提取常量\r\n\r\nCtrl + Alt + P提取参数\r\n\r\n8、控制VCS/Local History\r\n\r\nCtrl + K提交项目\r\n\r\nCtrl + T更新项目\r\n\r\nAlt + Shift + C查看最近的变化\r\n\r\nAlt + BackQuote(’)VCS快速弹出\r\n\r\n9、模版(Live Templates)\r\n\r\nCtrl + Alt + J当前行使用模版\r\n\r\nCtrl +Ｊ插入模版\r\n\r\n10、基本(General)\r\n\r\nAlt + #[0-9]打开相应的工具窗口\r\n\r\nCtrl + Alt + Y同步\r\n\r\nCtrl + Shift + F12最大化编辑开关\r\n\r\nAlt + Shift + F添加到最喜欢\r\n\r\nAlt + Shift + I根据配置检查当前文件\r\n\r\nCtrl + BackQuote(’)快速切换当前计划\r\n\r\nCtrl + Alt + S　打开设置页\r\n\r\nCtrl + Shift + A查找编辑器里所有的动作\r\n\r\nCtrl + Tab在窗口间进行切换\r\n\r\npycharm常用设置：\r\n\r\nfile -> Setting ->Editor\r\n\r\n设置Python自动引入包，要先在>general > autoimport-> python :show popup\r\n\r\n快捷键：Alt + Enter: 自动添加包\r\n\r\n“代码自动完成”时间延时设置\r\n\r\nCode Completion   -> Auto code completion in (ms):0  -> Autopopup in (ms):500\r\n\r\nPycharm中默认是不能用Ctrl+滚轮改变字体大小的，可以在〉Mouse中设置\r\n\r\n显示“行号”与“空白字符”\r\n\r\nAppearance  -> 勾选“Show line numbers”、“Show whitespaces”、“Show method separators”\r\n\r\n设置编辑器“颜色与字体”主题\r\n\r\nColors & Fonts -> Scheme name -> 选择\"monokai\"“Darcula”\r\n\r\n说明：先选择“monokai”，再“Save As”为\"monokai-pipi\"，因为默认的主题是“只读的”，一些字体大小颜色什么的都不能修改，拷贝一份后方可修改！\r\n\r\n修改字体大小\r\n\r\nColors & Fonts -> Font -> Size -> 设置为“14”\r\n\r\n设置缩进符为制表符“Tab”\r\n\r\nFile -> Default Settings -> Code Style\r\n\r\n-> General -> 勾选“Use tab character”\r\n\r\n-> Python -> 勾选“Use tab character”\r\n\r\n-> 其他的语言代码同理设置\r\n\r\n去掉默认折叠\r\n\r\nCode Folding -> Collapse by default -> 全部去掉勾选\r\n\r\npycharm默认是自动保存的，习惯自己按ctrl + s  的可以进行如下设置：\r\n\r\nGeneral -> Synchronization -> Save files on frame deactivation  和 Save files automatically if application is idle for .. sec 的勾去掉\r\n\r\nEditor Tabs -> Mark modified tabs with asterisk 打上勾\r\n\r\n9.>file and code template>python scripts\r\n\r\n!/usr/bin/env python\r\n\r\n-- coding: utf-8 --\r\n\r\n\"\"\"\r\n\r\ntitle = '$Package_name'\r\n\r\nauthor = '$USER'\r\n\r\nmtime = '$DATE'\r\n\r\ncode is far away from bugs with the god animal protecting\r\n\r\nI love animals. They taste delicious.\r\n\r\n┏┓      ┏┓\r\n\r\n┏┛┻━━━┛┻┓\r\n\r\n┃      ☃      ┃\r\n\r\n┃  ┳┛  ┗┳  ┃\r\n\r\n┃      ┻      ┃\r\n\r\n┗━┓      ┏━┛\r\n\r\n┃      ┗━━━┓\r\n\r\n┃  神兽保佑    ┣┓\r\n\r\n┃　永无BUG！   ┏┛\r\n\r\n┗┓┓┏━┳┓┏┛\r\n\r\n┃┫┫  ┃┫┫\r\n\r\n┗┻┛  ┗┻┛\r\n\r\n\"\"\"\r\n\r\n10 python文件默认编码\r\n\r\nFile Encodings> IDE Encoding: UTF-8;Project Encoding: UTF-8;\r\n\r\nFile -> Settings -> appearance\r\n\r\n修改IDE快捷键方案\r\n\r\nKeymap\r\n\r\n1) execute selection in console : add keymap > ctrl + enter\r\n\r\n系统自带了好几种快捷键方案，下拉框中有如“defaul”,“Visual Studio”,在查找Bug时非常有用,“NetBeans 6.5”,“Default for GNOME”等等可选项，\r\n\r\n因为“Eclipse”方案比较大众，个人用的也比较多，最终选择了“Eclipse”。\r\n\r\n还是有几个常用的快捷键跟Eclipse不一样，为了能修改，还得先对Eclipse方案拷贝一份：\r\n\r\n(1).代码提示功能，默认是【Ctrl+空格】，现改为跟Eclipse一样，即【Alt+/】\r\n\r\nMain menu -> code -> Completion -> Basic -> 设置为“Alt+/”\r\n\r\nMain menu -> code -> Completion -> SmartType -> 设置为“Alt+Shift+/”\r\n\r\n不过“Alt+/”默认又被\r\n\r\nMain menu -> code -> Completion -> Basic -> Cyclic Expand Word 占用，先把它删除再说吧(单击右键删除)！\r\n\r\n(2).关闭当前文档，默认是【Ctrl+F4】，现改为跟Eclipse一样，即【Ctrl+W】\r\n\r\nMain menu -> Window -> Active Tool Window -> Close Active Tab -> 设置为 “Ctrl+F4”;\r\n\r\nMain menu -> Window -> Editor -> Close -> 设置为 “Ctrl+W”;\r\n\r\n2.设置IDE皮肤主题\r\n\r\nTheme -> 选择“Alloy.IDEA Theme”\r\n\r\n或者在setting中搜索theme可以改变主题，所有配色统一改变\r\n\r\nFile > settings > build.excution\r\n\r\n1 console > pyconsole\r\n\r\nimportsys# print('Python %s on %s' % (sys.version, sys.platform))sys.path.extend([WORKING_DIR_AND_PYTHON_PATHS])importosprint('current workdirectory : ', os.getcwd() )importnumpyasnpimportscipyasspimportmatplotlibasmpl\r\n\r\nFile > settings > Project : initial project\r\n\r\nproject dependencies > LDA > project depends on these projects > 选择sim_cluster就可以在LDA中调用sim_cluster中的包\r\n\r\n[Configure PyCharm]\r\n\r\nPycharm实用功能：\r\n\r\n[PyCharm中的那些实用功能]\r\n\r\npycharm中配置python脚本和console执行路径和当前工作目录\r\n\r\n1 ctrl + shift + f10 / f10 执行python脚本时\r\n\r\n当前工作目录cwd为run/debug configurations 中的working directory\r\n\r\n可在edit configurations > project or defaults中配置\r\n\r\n2python console中执行时\r\n\r\ncwd为File > settings > build.excution > console > pyconsole中的working directory\r\n\r\n并可在其中配置\r\n\r\npycharm中进行python包管理\r\n\r\npycharm中的项目中可以包含package、目录(目录名可以有空格)、等等\r\n\r\n目录的某个包中的某个py文件要调用另一个py文件中的函数，首先要将目录设置为source root，这样才能从包中至上至上正确引入函数，否则怎么引入都出错：\r\n\r\nSystemError: Parent module '' not loaded, cannot perform relative import\r\n\r\nNote:目录 > 右键 > make directory as > source root\r\n\r\n1、编辑(Editing)\r\n\r\nCtrl + Space 基本的代码完成(类、方法、属性)\r\n\r\nCtrl + Alt + Space 快速导入任意类\r\n\r\nCtrl + Shift + Enter 语句完成\r\n\r\nCtrl + P 参数信息(在方法中调用参数)\r\n\r\nCtrl + Q 快速查看文档\r\n\r\nShift + F1 外部文档\r\n\r\nCtrl + 鼠标 简介\r\n\r\nCtrl + F1 显示错误描述或警告信息\r\n\r\nAlt + Insert 自动生成代码\r\n\r\nCtrl + O 重新方法\r\n\r\nCtrl + Alt + T 选中\r\n\r\nCtrl + / 行注释\r\n\r\nCtrl + Shift + / 块注释\r\n\r\nCtrl + W 选中增加的代码块\r\n\r\nCtrl + Shift + W 回到之前状态\r\n\r\nCtrl + Shift + ]/[ 选定代码块结束、开始\r\n\r\nAlt + Enter 快速修正\r\n\r\nCtrl + Alt + L 代码格式化\r\n\r\nCtrl + Alt + O 优化导入\r\n\r\nCtrl + Alt + I 自动缩进\r\n\r\nTab / Shift + Tab 缩进、不缩进当前行\r\n\r\nCtrl+X/Shift+Delete 剪切当前行或选定的代码块到剪贴板\r\n\r\nCtrl+C/Ctrl+Insert 复制当前行或选定的代码块到剪贴板\r\n\r\nCtrl+V/Shift+Insert 从剪贴板粘贴\r\n\r\nCtrl + Shift + V 从最近的缓冲区粘贴\r\n\r\nCtrl + D 复制选定的区域或行\r\n\r\nCtrl + Y 删除选定的行\r\n\r\nCtrl + Shift + J 添加智能线\r\n\r\nCtrl + Enter 智能线切割\r\n\r\nShift + Enter 另起一行\r\n\r\nCtrl + Shift + U 在选定的区域或代码块间切换\r\n\r\nCtrl + Delete 删除到字符结束\r\n\r\nCtrl + Backspace 删除到字符开始\r\n\r\nCtrl + Numpad+/- 展开折叠代码块\r\n\r\nCtrl + Numpad+ 全部展开\r\n\r\nCtrl + Numpad- 全部折叠\r\n\r\nCtrl + F4 关闭运行的选项卡\r\n\r\n2、查找/替换(Search/Replace)\r\n\r\nF3 下一个\r\n\r\nShift + F3 前一个\r\n\r\nCtrl + R 替换\r\n\r\nCtrl + Shift + F 全局查找\r\n\r\nCtrl + Shift + R 全局替换\r\n\r\n3、运行(Running)\r\n\r\nAlt + Shift + F10 运行模式配置\r\n\r\nAlt + Shift + F9 调试模式配置\r\n\r\nShift + F10 运行\r\n\r\nShift + F9 调试\r\n\r\nCtrl + Shift + F10 运行编辑器配置\r\n\r\nCtrl + Alt + R 运行manage.py任务\r\n\r\n4、调试(Debugging)\r\n\r\nF8 跳过\r\n\r\nF7 进入\r\n\r\nShift + F8 退出\r\n\r\nAlt + F9 运行游标\r\n\r\nAlt + F8 验证表达式\r\n\r\nCtrl + Alt + F8 快速验证表达式\r\n\r\nF9 恢复程序\r\n\r\nCtrl + F8 断点开关\r\n\r\nCtrl + Shift + F8 查看断点\r\n\r\n5、导航(Navigation)\r\n\r\nCtrl + N 跳转到类\r\n\r\nCtrl + Shift + N 跳转到符号\r\n\r\nAlt + Right/Left 跳转到下一个、前一个编辑的选项卡\r\n\r\nF12 回到先前的工具窗口\r\n\r\nEsc 从工具窗口回到编辑窗口\r\n\r\nShift + Esc 隐藏运行的、最近运行的窗口\r\n\r\nCtrl + Shift + F4 关闭主动运行的选项卡\r\n\r\nCtrl + G 查看当前行号、字符号\r\n\r\nCtrl + E 当前文件弹出\r\n\r\nCtrl+Alt+Left/Right 后退、前进\r\n\r\nCtrl+Shift+Backspace 导航到最近编辑区域\r\n\r\nAlt + F1 查找当前文件或标识\r\n\r\nCtrl+B / Ctrl+Click 跳转到声明\r\n\r\nCtrl + Alt + B 跳转到实现\r\n\r\nCtrl + Shift + I查看快速定义\r\n\r\nCtrl + Shift + B跳转到类型声明\r\n\r\nCtrl + U跳转到父方法、父类\r\n\r\nAlt + Up/Down跳转到上一个、下一个方法\r\n\r\nCtrl + ]/[跳转到代码块结束、开始\r\n\r\nCtrl + F12弹出文件结构\r\n\r\nCtrl + H类型层次结构\r\n\r\nCtrl + Shift + H方法层次结构\r\n\r\nCtrl + Alt + H调用层次结构\r\n\r\nF2 / Shift + F2下一条、前一条高亮的错误\r\n\r\nF4 / Ctrl + Enter编辑资源、查看资源\r\n\r\nAlt + Home显示导航条F11书签开关\r\n\r\nCtrl + Shift + F11书签助记开关\r\n\r\nCtrl + #[0-9]跳转到标识的书签\r\n\r\nShift + F11显示书签\r\n\r\n6、搜索相关(Usage Search)\r\n\r\nAlt + F7/Ctrl + F7文件中查询用法\r\n\r\nCtrl + Shift + F7文件中用法高亮显示\r\n\r\nCtrl + Alt + F7显示用法\r\n\r\n7、重构(Refactoring)\r\n\r\nF5复制F6剪切\r\n\r\nAlt + Delete安全删除\r\n\r\nShift + F6重命名\r\n\r\nCtrl + F6更改签名\r\n\r\nCtrl + Alt + N内联\r\n\r\nCtrl + Alt + M提取方法\r\n\r\nCtrl + Alt + V提取属性\r\n\r\nCtrl + Alt + F提取字段\r\n\r\nCtrl + Alt + C提取常量\r\n\r\nCtrl + Alt + P提取参数\r\n\r\n8、控制VCS/Local History\r\n\r\nCtrl + K提交项目\r\n\r\nCtrl + T更新项目\r\n\r\nAlt + Shift + C查看最近的变化\r\n\r\nAlt + BackQuote(’)VCS快速弹出\r\n\r\n9、模版(Live Templates)\r\n\r\nCtrl + Alt + J当前行使用模版\r\n\r\nCtrl +Ｊ插入模版\r\n\r\n10、基本(General)\r\n\r\nAlt + #[0-9]打开相应的工具窗口\r\n\r\nCtrl + Alt + Y同步\r\n\r\nCtrl + Shift + F12最大化编辑开关\r\n\r\nAlt + Shift + F添加到最喜欢\r\n\r\nAlt + Shift + I根据配置检查当前文件\r\n\r\nCtrl + BackQuote(’)快速切换当前计划\r\n\r\nCtrl + Alt + S　打开设置页\r\n\r\nCtrl + Shift + A查找编辑器里所有的动作\r\n\r\nCtrl + Tab在窗口间进行切换", "note_img": "uploads/blog/blog.jpeg", "create_time": "2022-07-22T16:58:44.918", "update_time": "2022-07-22T21:12:39.354", "click_num": 3, "love_num": 0, "user": 1}}, {"model": "blog.note", "pk": 4, "fields": {"title": "django基础命令", "desc": "暂无简介", "content": "#django\r\n## 1.#创建项目\r\ndjango-admin startproject mysite\r\n启动服务测试下\r\npython manage.py runserver 0:8000 这里ip:port指定只能本机使用127.0.0.1的8000端口访问，也可以为空\r\n\r\n##2.创建应用app名 例如users\r\npython manage.py startapp firstapp\r\npython manage.py startapp users\r\n\r\n##3.设计数据模型\r\n    views.py（修改后都需要执行4）\r\n    class 表名字\r\n   检查项：   settings是否设置好数据库（每天就新建数据库并且填好，见附1）和注册好app\r\n            写好urls\r\n            init.py里面导入pymysql模块，import pymysql，pymysql.install_as_MySQLdb()\r\n\r\n##4.数据库迁移\r\npython manage.py makemigrations #创建迁移文件，如果没修改会No changes detected\r\npython manage.py migrate 数据库迁移\r\n如果动了数据库，后期需要大修改表\r\n    到数据库把本app中的表都删掉\r\n    删除本app文件夹下的migrations目录内所有文件，除了__init__.py\r\n    在数据库中，找到django_migrations表，删除本app对应的记录；至此，就把之前的迁移记录都删掉了\r\n    重新迁移\r\n直接：注释掉原来的库类和路由视图函数，python manage.py makemigrations app\r\n                python manage.py migrate，会出现delete ...\r\n     修改好，重新迁移", "note_img": "uploads/blog/2022/07/23/blog_6.jpeg", "create_time": "2022-07-22T19:37:03.785", "update_time": "2022-07-23T16:57:35.853", "click_num": 25, "love_num": 0, "user": 2}}, {"model": "blog.note", "pk": 5, "fields": {"title": "django多表数据的添加查询（一对一、一对多、多对多关系）ORM", "desc": "暂无简介", "content": "一、创建表\r\n我们假设有这样的数据表，表中已经用OneToOneField、ForeignKey、ManyToManyField表达了一对一、一对多、多对多关系\r\n\r\nclass Book(models.Model):\r\n    title = models.CharField(max_length=32)\r\n    price = models.DecimalField(max_digits=5, decimal_places=2)\r\n    pub_date = models.DateField()\r\n    publish = models.ForeignKey(\"Publish\", on_delete=models.CASCADE)\r\n    authors = models.ManyToManyField(\"Author\")\r\n\r\n\r\nclass Publish(models.Model):\r\n    name = models.CharField(max_length=32)\r\n    city = models.CharField(max_length=64)\r\n    email = models.EmailField()\r\n\r\n\r\nclass Author(models.Model):\r\n    name = models.CharField(max_length=32)\r\n    age = models.SmallIntegerField()\r\n    au_detail = models.OneToOneField(\"AuthorDetail\", on_delete=models.CASCADE)\r\n\r\n\r\nclass AuthorDetail(models.Model):\r\n    gender_choices = (\r\n        (0, \"女\"),\r\n        (1, \"男\"),\r\n        (2, \"保密\"),\r\n    )\r\n    gender = models.SmallIntegerField(choices=gender_choices)\r\n    tel = models.CharField(max_length=32)\r\n    addr = models.CharField(max_length=64)\r\n    birthday = models.DateField()\r\n\r\n表结构\r\n\r\n书籍表 Book：title 、 price 、 pub_date 、 publish（外键，多对一） 、 authors（多对多）\r\n\r\n出版社表 Publish：name 、 city 、 email\r\n\r\n作者表 Author：name 、 age 、 au_detail（一对一）\r\n\r\n作者详情表 AuthorDetail：gender 、 tel 、 addr 、 birthday\r\n\r\n二、ORM添加数据\r\n（1）一对多(外键 ForeignKey)\r\n\r\n方式一: 传对象的形式，返回值的数据类型是对象，书籍对象。\r\n步骤：\r\n\r\na. 获取出版社对象\r\nb. 给书籍的出版社属性 pulish 传出版社对象\r\n\r\ndef add_book(request):\r\n    #  获取出版社对象\r\n    pub_obj = models.Publish.objects.filter(pk=1).first()\r\n    #  给书籍的出版社属性publish传出版社对象\r\n    book = models.Book.objects.create(title=\"菜鸟教程\", price=200, pub_date=\"2010-10-10\", publish=pub_obj)\r\n    print(book, type(book))\r\n    return HttpResponse(book)\r\n\r\n方式二: 传对象 id 的形式(由于传过来的数据一般是 id,所以传对象 id 是常用的)。\r\n\r\n一对多中，设置外键属性的类(多的表)中，MySQL 中显示的字段名是:外键属性名_id。\r\n\r\n返回值的数据类型是对象，书籍对象。\r\n\r\n步骤：\r\n\r\na. 获取出版社对象的 id\r\nb. 给书籍的关联出版社字段 pulish_id 传出版社对象的 id\r\n\r\ndef add_book(request):\r\n    #  获取出版社对象\r\n    pub_obj = models.Publish.objects.filter(pk=1).first()\r\n    #  获取出版社对象的id\r\n    pk = pub_obj.pk\r\n    #  给书籍的关联出版社字段 publish_id 传出版社对象的id\r\n    book = models.Book.objects.create(title=\"冲灵剑法\", price=100, pub_date=\"2004-04-04\", publish_id=pk)\r\n    print(book, type(book))\r\n    return HttpResponse(book)\r\n\r\n（2）多对多(ManyToManyField)：在第三张关系表中新增数据、\r\n方式一: 传对象形式，无返回值。\r\n\r\n步骤：\r\n\r\na. 获取作者对象\r\nb. 获取书籍对象\r\nc. 给书籍对象的 authors 属性用 add 方法传作者对象\r\n\r\ndef add_book(request):\r\n    #  获取作者对象\r\n    chong = models.Author.objects.filter(name=\"令狐冲\").first()\r\n    ying = models.Author.objects.filter(name=\"任盈盈\").first()\r\n    #  获取书籍对象\r\n    book = models.Book.objects.filter(title=\"菜鸟教程\").first()\r\n    #  给书籍对象的 authors 属性用 add 方法传作者对象\r\n    book.authors.add(chong, ying)\r\n    return HttpResponse(book)\r\n\r\n方式二: 传对象id形式，无返回值。\r\n\r\n步骤：\r\n\r\na. 获取作者对象的 id\r\nb. 获取书籍对象\r\nc. 给书籍对象的 authors 属性用 add 方法传作者对象的 id\r\n\r\ndef add_book(request):\r\n    #  获取作者对象\r\n    chong = models.Author.objects.filter(name=\"令狐冲\").first()\r\n    #  获取作者对象的id\r\n    pk = chong.pk\r\n    #  获取书籍对象\r\n    book = models.Book.objects.filter(title=\"冲灵剑法\").first()\r\n    #  给书籍对象的 authors 属性用 add 方法传作者对象的id\r\n    book.authors.add(pk)\r\n\r\n三、关联管理器（对象调用）\r\n前提：\r\n\r\n多对多（双向均有关联管理器）\r\n一对多（只有多的那个类的对象有关联管理器，即反向才有）\r\n\r\n语法格式：\r\n\r\n正向：属性名\r\n反向：小写类名加 _set\r\n\r\n注意：一对多只能反向\r\n\r\n常用方法：\r\n\r\nadd()：用于多对多，把指定的模型对象添加到关联对象集（关系表）中。\r\n\r\n注意：add() 在一对多(即外键)中，只能传对象（ QuerySet数据类型），不能传 id（[id表]）。\r\n\r\n*[ ] 的使用:\r\n方式一：传对象\r\n\r\nbook_obj = models.Book.objects.get(id=10)\r\nauthor_list = models.Author.objects.filter(id__gt=2)\r\nbook_obj.authors.add(*author_list)  # 将 id 大于2的作者对象添加到这本书的作者集合中\r\n# 方式二：传对象 id\r\nbook_obj.authors.add(*[1,3]) # 将 id=1 和 id=3 的作者对象添加到这本书的作者集合中\r\nreturn HttpResponse(\"ok\")\r\n\r\n反向：小写表名_set\r\n\r\nying = models.Author.objects.filter(name=\"任盈盈\").first()\r\nbook = models.Book.objects.filter(title=\"冲灵剑法\").first()\r\nying.book_set.add(book)\r\nreturn HttpResponse(\"ok\")\r\n\r\ncreate()：创建一个新的对象，并同时将它添加到关联对象集之中。\r\n\r\n返回新创建的对象。\r\n\r\npub = models.Publish.objects.filter(name=\"明教出版社\").first()\r\nwo = models.Author.objects.filter(name=\"任我行\").first()\r\nbook = wo.book_set.create(title=\"吸星大法\", price=300, pub_date=\"1999-9-19\", publish=pub)\r\nprint(book, type(book))\r\nreturn HttpResponse(\"ok\")\r\n\r\nremove()：从关联对象集中移除执行的模型对象。\r\n\r\n对于 ForeignKey 对象，这个方法仅在 null=True（可以为空）时存在，无返回值。\r\n\r\nauthor_obj =models.Author.objects.get(id=1)\r\nbook_obj = models.Book.objects.get(id=11)\r\nauthor_obj.book_set.remove(book_obj)\r\nreturn HttpResponse(\"ok\")\r\n\r\nclear()：从关联对象集中移除一切对象，删除关联，不会删除对象。\r\n\r\n对于 ForeignKey 对象，这个方法仅在 null=True（可以为空）时存在。\r\n\r\n无返回值。\r\n\r\n#  清空独孤九剑关联的所有作者\r\nbook = models.Book.objects.filter(title=\"菜鸟教程\").first()\r\nbook.authors.clear()\r\n\r\n四、ORM查询\r\n\r\n一对多\r\n\r\n查询主键为 1 的书籍的出版社所在的城市（正向）。\r\n\r\nbook = models.Book.objects.filter(pk=10).first()\r\nres = book.publish.city\r\nprint(res, type(res))\r\nreturn HttpResponse(\"ok\")\r\n\r\n查询明教出版社出版的书籍名（反向）。\r\n\r\n反向：对象.小写类名_set(pub.book_set) 可以跳转到关联的表(书籍表)。\r\n\r\npub.book_set.all()：取出书籍表的所有书籍对象，在一个 QuerySet 里，遍历取出一个个书籍对象。\r\n\r\npub = models.Publish.objects.filter(name=\"明教出版社\").first()\r\nres = pub.book_set.all()\r\nfor i in res:\r\n    print(i.title)\r\nreturn HttpResponse(\"ok\")\r\n\r\n一对一\r\n\r\n查询令狐冲的电话（正向）\r\n\r\n正向：对象.属性 (author.au_detail) 可以跳转到关联的表(作者详情表)\r\n\r\nauthor = models.Author.objects.filter(name=\"令狐冲\").first()\r\nres = author.au_detail.tel\r\nprint(res, type(res))\r\nreturn HttpResponse(\"ok\")\r\n\r\n查询所有住址在黑木崖的作者的姓名（反向）。\r\n\r\n一对一的反向，用 对象.小写类名 即可，不用加 _set。\r\n\r\n反向：对象.小写类名(addr.author)可以跳转到关联的表(作者表)。\r\n\r\naddr = models.AuthorDetail.objects.filter(addr=\"黑木崖\").first()\r\nres = addr.author.name\r\nprint(res, type(res))\r\nreturn HttpResponse(\"ok\")\r\n\r\n多对多\r\n\r\n菜鸟教程所有作者的名字以及手机号（正向）。\r\n\r\n正向：对象.属性(book.authors)可以跳转到关联的表(作者表)。\r\n\r\n作者表里没有作者电话，因此再次通过对象.属性(i.au_detail)跳转到关联的表（作者详情表）。\r\n\r\nbook = models.Book.objects.filter(title=\"菜鸟教程\").first()\r\nres = book.authors.all()\r\nfor i in res:\r\n    print(i.name, i.au_detail.tel)\r\nreturn HttpResponse(\"ok\")\r\n\r\n查询任我行出过的所有书籍的名字（反向）。\r\n\r\nauthor = models.Author.objects.filter(name=\"任我行\").first()\r\nres = author.book_set.all()\r\nfor i in res:\r\n    print(i.title)\r\nreturn HttpResponse(\"ok\")\r\n\r\n五、基于双下划线的跨表查询\r\n正向：属性名称__跨表的属性名称 反向：小写类名__跨表的属性名称\r\n一对多\r\n\r\n查询菜鸟出版社出版过的所有书籍的名字与价格。\r\n\r\nres = models.Book.objects.filter(publish__name=\"菜鸟出版社\").values_list(\"title\", \"price\")\r\n1\r\n反向：通过 小写类名__跨表的属性名称（book__title，book__price） 跨表获取数据。\r\n\r\nres = models.Publish.objects.filter(name=\"菜鸟出版社\").values_list(\"book__title\",\"book__price\")\r\nreturn HttpResponse(\"ok\")\r\n\r\n多对多\r\n\r\n查询任我行出过的所有书籍的名字。\r\n\r\n正向：通过 属性名称__跨表的属性名称(authors__name) 跨表获取数据：\r\n\r\nres = models.Book.objects.filter(authors__name=\"任我行\").values_list(\"title\")\r\n1\r\n反向：通过 小写类名__跨表的属性名称（book__title） 跨表获取数据：\r\n\r\nres = models.Author.objects.filter(name=\"任我行\").values_list(\"book__title\")\r\n\r\n一对一\r\n\r\n查询任我行的手机号。\r\n\r\n正向：通过 属性名称__跨表的属性名称(au_detail__tel) 跨表获取数据。\r\n\r\nres = models.Author.objects.filter(name=\"任我行\").values_list(\"au_detail__tel\")\r\n\r\n反向：通过 小写类名__跨表的属性名称（author__name） 跨表获取数据。\r\n\r\nres = models.AuthorDetail.objects.filter(author__name=\"任我行\").values_list(\"tel\")", "note_img": "uploads/blog/blog.jpeg", "create_time": "2022-07-22T21:17:41.484", "update_time": "2022-07-22T21:17:41.484", "click_num": 3, "love_num": 0, "user": 3}}, {"model": "blog.note", "pk": 6, "fields": {"title": "django管理员", "desc": "暂无简介", "content": "## 删除管理员\r\n```c\r\n[app@sanrenxing365 mysite]$ python3 manage.py shell\r\n\r\nPython 3.8.10 (default, Jan  7 2022, 17:01:54) \r\n\r\n[GCC 8.5.0 20210514 (Red Hat 8.5.0-4)] on linux\r\n\r\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\r\n\r\n(InteractiveConsole)\r\n\r\n>>> from django.contrib.auth.models import User\r\n\r\n>>> User.objects.get(username=\"admin\", is_superuser=True).delete()\r\n\r\n(1, {'auth.User': 1})\r\n```", "note_img": "uploads/blog/blog.jpeg", "create_time": "2022-07-22T21:19:13.132", "update_time": "2022-07-22T21:19:13.132", "click_num": 21, "love_num": 0, "user": 7}}, {"model": "blog.note", "pk": 7, "fields": {"title": "python中 列表（List）转换为字符串（Str）的方法", "desc": "暂无简介", "content": "# 1、List列表转为Str字符串\r\nList中存的是字符串的时候，一般是通过.join()函数去转换\r\n```python\r\n例 ：\r\n    dataList = ['1', '2', '3', '4' ]\r\n    str1 = “ ， ” + join(dataList )\r\n    print (dataList)\r\n\r\n\t结果：\r\n\ta b c d \r\n```\r\n# 2、Str转为List列表\r\n主要就是通过str的split()函数，如果为空就用空格标识：\r\n例：\r\n```python\r\n    str1 = 'abcde'\r\n    str2 = 'a b c d   e'\r\n    str3 = 'a, b, c, d, e'\r\n    result1 = list(str1)\r\n    result2 = str2.split()\r\n    result3 = str3.split(', ')\r\n    print(result1)\r\n    print(result2)\r\n    \r\n    结果：\r\n    ['a', 'b', 'c', 'd', 'e']\r\n    ['a', 'b', 'c', 'd', 'e']\r\n    ['a', 'b', 'c', 'd', 'e']\r\n\r\n```", "note_img": "uploads/blog/2022/07/23/blog_13.jpeg", "create_time": "2022-07-22T21:22:14.390", "update_time": "2022-07-23T16:58:29.204", "click_num": 2, "love_num": 0, "user": 6}}, {"model": "blog.note", "pk": 8, "fields": {"title": "cython和python分别是什么？区别有哪些", "desc": "暂无简介", "content": "从字面上来讲，cython和python经常会被混淆在一起，也经常会有人问cython和python区别是什么?它们之间有什么关系或联系?对此小编特整理了这篇文章，我们一起来看看吧。\r\n\r\n　　Cython是Python的一个超集，结合了Python的易用性和原生代码的速度，可以编译成C语言，产生的性能提升可以从几个百分点到几个数量级，具体取决于手头的任务。\r\n\r\n　　使用Cython，你可以避开Python的许多原生限制，或者完全超越Python，而无需放弃Python的简便性和便捷性。\r\n\r\n　　Python代码可以直接调用C模块。这些C模块可以是通用的C库或专门为Python工作的库。Cython生成第二种类型的模块：与Python内部对话的C库，可以与现有的Python代码绑定在一起。\r\n\r\n　　Cython代码在设计上看起来很像Python代码。如果你给Cython编译器提供了一个Python程序，它将会按原样接受它，但是Cython的原生加速器都不会起作用。但是如果你用Cython的特殊语法来修饰Python代码，那么Cython就可以用快速的C代替慢的Python对象。\r\n\r\n　　请注意，Cython的方法是渐进的。这意味着开发人员可以从现有的Python应用程序开始，通过对代码立刻进行更改来加快速度，而不是从头开始重写整个应用程序。\r\n\r\n　　这种方法通常与软件性能问题的性质相吻合。在大多数程序中，绝大多数CPU密集型代码都集中在一些热点上，也就是帕累托原则的一个版本，也被称为80/20规则。因此，Python应用程序中的大部分代码不需要进行性能优化，只需要几个关键部分。你可以逐渐将这些热点转换为Cython，从而获得你最需要的性能提升。程序的其余部分可以保留在Python中，以方便开发人员。\r\n-----------------------------------\r\n©著作权归作者所有：来自51CTO博客作者老男孩IT教育的原创作品，请联系作者获取转载授权，否则将追究法律责任\r\ncython和python分别是什么？区别有哪些？\r\nhttps://blog.51cto.com/u_15052541/5504082", "note_img": "uploads/blog/blog.jpeg", "create_time": "2022-07-22T21:24:45.114", "update_time": "2022-07-22T21:24:45.114", "click_num": 8, "love_num": 0, "user": 2}}, {"model": "blog.note", "pk": 9, "fields": {"title": "Spring Boot思绪梳理", "desc": "暂无简介", "content": "Spring Boot思绪梳理\r\n\r\n关于 Spring Boot + Vue3 的动态菜单，松哥之前曾经写了两篇文章了，这两篇文章主要是从代码上和大家剖析动态菜单最终的完成方式，但是还是有小同伴觉得没太看明白，觉得缺乏一个大纲挈领的思绪，所以，今天松哥再整一篇文章和大家再来捋一捋这个问题，希望这篇文章能让小同伴们彻底搞分明这个问题。\r\n\r\n\r\n\r\n1. 整体思绪\r\n\r\n首先我们来看整体思绪。\r\n\r\n\r\n\r\n有父有子：像系统管理那种，既有父菜单，又有子菜单。\r\n\r\n只要一个一级菜单，这种又细分为三种状况\r\n\r\n\r\n\r\n普通的菜单，点击之后在右边主页面翻开某个功用页面。\r\n\r\n一个超链接，但不是外链，是一个在当前系统中翻开的外部网页，点击之后，会在右边的主页面中新开一个选项卡，这个选项卡中显现的是一个外部网页（实质上是经过 iframe 标签引入的一个外部网页）。\r\n\r\n一个超链接，并且还是一个外链，点击之后，直接在阅读器中翻开一个新的选项卡，新的选项卡中展现一个外部链接。\r\n\r\n\r\n\r\n四种菜单对应的 JSON 格式分别如下：\r\n\r\n\r\n\r\n有父有子：\r\n\r\n\r\n\r\n{\r\n\r\n   \"name\": \"Monitor\",\r\n\r\n   \"path\": \"/monitor\",\r\n\r\n   \"hidden\": false,\r\n\r\n   \"redirect\": \"noRedirect\",\r\n\r\n   \"component\": \"Layout\",\r\n\r\n   \"alwaysShow\": true,\r\n\r\n   \"meta\": {\r\n\r\n       \"title\": \"系统监控\",\r\n\r\n       \"icon\": \"monitor\",\r\n\r\n       \"noCache\": false,\r\n\r\n       \"link\": null\r\n\r\n   },\r\n\r\n   \"children\": [{\r\n\r\n       \"name\": \"Online\",\r\n\r\n       \"path\": \"online\",\r\n\r\n       \"hidden\": false,\r\n\r\n       \"component\": \"monitor/online/index\",\r\n\r\n       \"meta\": {\r\n\r\n           \"title\": \"在线用户\",\r\n\r\n           \"icon\": \"online\",\r\n\r\n           \"noCache\": false,\r\n\r\n           \"link\": null\r\n\r\n       }\r\n\r\n   }, {\r\n\r\n       \"name\": \"Job\",\r\n\r\n       \"path\": \"job\",\r\n\r\n       \"hidden\": false,\r\n\r\n       \"component\": \"monitor/job/index\",\r\n\r\n       \"meta\": {\r\n\r\n           \"title\": \"定时任务\",\r\n\r\n           \"icon\": \"job\",\r\n\r\n           \"noCache\": false,\r\n\r\n           \"link\": null\r\n\r\n       }\r\n\r\n   }]\r\n\r\n}\r\n\r\n复制代码\r\n\r\n\r\n\r\n只要一个一级菜单，且一级菜单点击后是一个功用页面：\r\n\r\n\r\n\r\n{\r\n\r\n   \"path\": \"/\",\r\n\r\n   \"hidden\": false,\r\n\r\n   \"component\": \"Layout\",\r\n\r\n   \"children\": [{\r\n\r\n       \"name\": \"Role\",\r\n\r\n       \"path\": \"role\",\r\n\r\n       \"hidden\": false,\r\n\r\n       \"component\": \"system/role/index\",\r\n\r\n       \"meta\": {\r\n\r\n           \"title\": \"角色管理\",\r\n\r\n           \"icon\": \"peoples\",\r\n\r\n           \"noCache\": false,\r\n\r\n           \"link\": null\r\n\r\n       }\r\n\r\n   }]\r\n\r\n}\r\n\r\n复制代码\r\n\r\n\r\n\r\n只要一个一级菜单，且一级菜单点击之后在当前系统中一个新的选项卡里翻开一个网页：\r\n\r\n\r\n\r\n{\r\n\r\n   \"name\": \"Http://www.javaboy.org\",\r\n\r\n   \"path\": \"/\",\r\n\r\n   \"hidden\": false,\r\n\r\n   \"component\": \"Layout\",\r\n\r\n   \"meta\": {\r\n\r\n       \"title\": \"TienChin健身官网\",\r\n\r\n       \"icon\": \"guide\",\r\n\r\n       \"noCache\": false,\r\n\r\n       \"link\": null\r\n\r\n   },\r\n\r\n   \"children\": [\r\n\r\n       {\r\n\r\n           \"name\": \"Www.javaboy.org\",\r\n\r\n           \"path\": \"www.javaboy.org\",\r\n\r\n           \"hidden\": false,\r\n\r\n           \"component\": \"InnerLink\",\r\n\r\n           \"meta\": {\r\n\r\n               \"title\": \"TienChin健身官网\",\r\n\r\n               \"icon\": \"guide\",\r\n\r\n               \"noCache\": false,\r\n\r\n               \"link\": \"http://www.javaboy.org\"\r\n\r\n           }\r\n\r\n       }\r\n\r\n   ]\r\n\r\n}\r\n\r\n复制代码\r\n\r\n\r\n\r\n只要一个一级菜单，且一级菜单点击之后在阅读器翻开一个新的选项卡：\r\n\r\n\r\n\r\n{\r\n\r\n   \"name\": \"Http://www.javaboy.org\",\r\n\r\n   \"path\": \"http://www.javaboy.org\",\r\n\r\n   \"hidden\": false,\r\n\r\n   \"component\": \"Layout\",\r\n\r\n   \"meta\": {\r\n\r\n       \"title\": \"TienChin健身官网\",\r\n\r\n       \"icon\": \"guide\",\r\n\r\n       \"noCache\": false,\r\n\r\n       \"link\": \"http://www.javaboy.org\"\r\n\r\n   }\r\n\r\n}\r\n\r\n复制代码\r\n\r\n依据以上四种不同的 JSON，我们总结出以下规律：\r\n\r\n\r\n\r\n父组件都是 Layout，这里的 Layout 就相当于我们 vhr 中的 Home 组件，也就是整个页面的框架。\r\n\r\n假如想在当前系统中，新开选项卡翻开一个功用项，那么这个菜单项必然有 children，即便 children 中只要一项菜单。\r\n\r\n假如菜单项是一个外链，那么这个菜单项就不需求有 children 了。\r\n\r\n某种水平上，我们其实能够将 2、3 归为一类，毕竟 3 只是展现内容的组件固定为 InnerLink，2 则视状况而定。\r\n\r\n整体上，能够点击的菜单的 path 都是父菜单的 path + 子菜单的 path，假如菜单项有父有子，那就正常拼接就行了；假如只要一个子菜单，那么父菜单的 path 就是 /；假如是一个外链，那就只要父菜单的 path 了。\r\n\r\n\r\n\r\n好了，这就是动态菜单的整体设计。\r\n\r\n\r\n\r\n2. 前端渲染\r\n\r\n接下来我们再来看一看前端的菜单渲染，前端的动态菜单渲染位于 tienchin-ui/src/layout/components/Sidebar/SidebarItem.vue 文件中：\r\n\r\n\r\n\r\n<template>\r\n\r\n <div v-if=\"!item.hidden\">\r\n\r\n   <template v-if=\"hasOneShowingChild(item.children, item) && (!onlyOneChild.children || onlyOneChild.noShowingChildren) && !item.alwaysShow\">\r\n\r\n     <app-link v-if=\"onlyOneChild.meta\" :to=\"resolvePath(onlyOneChild.path, onlyOneChild.query)\">\r\n\r\n       <el-menu-item :index=\"resolvePath(onlyOneChild.path)\" :class=\"{ 'submenu-title-noDropdown': !isNest }\">\r\n\r\n         <svg-icon :icon-class=\"onlyOneChild.meta.icon || (item.meta && item.meta.icon)\"/>\r\n\r\n         <template #title><span class=\"menu-title\" :title=\"hasTitle(onlyOneChild.meta.title)\">{{ onlyOneChild.meta.title }}</span></template>\r\n\r\n       </el-menu-item>\r\n\r\n     </app-link>\r\n\r\n   </template>\r\n\r\n\r\n\r\n   <el-sub-menu v-else ref=\"subMenu\" :index=\"resolvePath(item.path)\" popper-append-to-body>\r\n\r\n     <template v-if=\"item.meta\" #title>\r\n\r\n       <svg-icon :icon-class=\"item.meta && item.meta.icon\" />\r\n\r\n       <span class=\"menu-title\" :title=\"hasTitle(item.meta.title)\">{{ item.meta.title }}</span>\r\n\r\n     </template>\r\n\r\n\r\n\r\n     <sidebar-item\r\n\r\n       v-for=\"child in item.children\"\r\n\r\n       :key=\"child.path\"\r\n\r\n       :is-nest=\"true\"\r\n\r\n       :item=\"child\"\r\n\r\n       :base-path=\"resolvePath(child.path)\"\r\n\r\n       class=\"nest-menu\"\r\n\r\n     />\r\n\r\n   </el-sub-menu>\r\n\r\n </div>\r\n\r\n</template>\r\n\r\n复制代码\r\n\r\n这里触及到几个办法，详细的办法细节我就不贴出来了，主要和大家说下完成思绪。\r\n\r\n\r\n\r\n先看整体上，这个菜单要是非躲藏的，躲藏的菜单，那么直接一级菜单及其下的子菜单就都不渲染了。\r\n\r\n渲染整体上分两块，上面的 template 主要是渲染只要一个子菜单的状况，也就是第一小节的 2、3、4 三种状况，下面的渲染正常的有父有子的状况，也就是第一小节的菜单 1。\r\n\r\nhasOneShowingChild 主要是判别这个菜单项能否只要一个需求渲染的子菜单，假如有多个子菜单，但是大局部都是躲藏，只要一个需求渲染出来，那也算只要一个子菜单，假如一个菜单项都没有子菜单，那也算一个子菜单，只不过这个子菜单就是他本身，对应第一小节第 4 种状况。在判别的过程中，将独一需求渲染的菜单的数据赋值给 onlyOneChild 变量，那么最终，假如当前菜单项只要一个子菜单，且这个子菜单没有子菜单（或者有子菜单但是子菜单不用显现），并且当前菜单也不是必需要渲染的，那就将 onlyOneChild 的数据渲染出来。\r\n\r\n关于普通的有父有子的状况，渲染的时分，经过 el-sub-menu 标签停止渲染，但是留意子项是 sidebar-item，sidebar-item 其实就是当前项！换言之，这里的渲染其实还用到了递归（直到没有 children 的时分完毕），这样即使菜单有三级四级五级等等，只需不嫌难看，都是能够渲染出来的。\r\n\r\n\r\n\r\n3. 后端菜单生成\r\n\r\n3.1 菜单表\r\n\r\n首先我们来看看菜单表的定义，也就是 sys_menu。\r\n\r\n\r\n\r\nCREATE TABLE `sys_menu` (\r\n\r\n `menu_id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '菜单ID',\r\n\r\n `menu_name` varchar(50) COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '菜单称号',\r\n\r\n `parent_id` bigint(20) DEFAULT '0' COMMENT '父菜单ID',\r\n\r\n `order_num` int(4) DEFAULT '0' COMMENT '显现次第',\r\n\r\n `path` varchar(200) COLLATE utf8mb4_unicode_ci DEFAULT '' COMMENT '路由地址',\r\n\r\n `component` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '组件途径',\r\n\r\n `query` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '路由参数',\r\n\r\n `is_frame` int(1) DEFAULT '1' COMMENT '能否为外链（0是 1否）',\r\n\r\n `is_cache` int(1) DEFAULT '0' COMMENT '能否缓存（0缓存 1不缓存）',\r\n\r\n `menu_type` char(1) COLLATE utf8mb4_unicode_ci DEFAULT '' COMMENT '菜单类型（M目录 C菜单 F按钮）',\r\n\r\n `visible` char(1) COLLATE utf8mb4_unicode_ci DEFAULT '0' COMMENT '菜单状态（0显现 1躲藏）',\r\n\r\n `status` char(1) COLLATE utf8mb4_unicode_ci DEFAULT '0' COMMENT '菜单状态（0正常 1停用）',\r\n\r\n `perms` varchar(100) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '权限标识',\r\n\r\n `icon` varchar(100) COLLATE utf8mb4_unicode_ci DEFAULT '#' COMMENT '菜单图标',\r\n\r\n `create_by` varchar(64) COLLATE utf8mb4_unicode_ci DEFAULT '' COMMENT '创立者',\r\n\r\n `create_time` datetime DEFAULT NULL COMMENT '创立时间',\r\n\r\n `update_by` varchar(64) COLLATE utf8mb4_unicode_ci DEFAULT '' COMMENT '更新者',\r\n\r\n `update_time` datetime DEFAULT NULL COMMENT '更新时间',\r\n\r\n `remark` varchar(500) COLLATE utf8mb4_unicode_ci DEFAULT '' COMMENT '备注',\r\n\r\n PRIMARY KEY (`menu_id`)\r\n\r\n) ENGINE=InnoDB AUTO_INCREMENT=3054 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='菜单权限表';\r\n\r\n复制代码\r\n\r\n其实这里很多字段都和我们 vhr 项目项目很类似，我也就不反复啰嗦了，我这里主要和小同伴们说一个字段，那就是 menu_type。\r\n\r\nmenu_type 表示一个菜单字段的类型，一个菜单有三品种型，分别是目录（M）、菜单（C）以及按钮（F）。这里所说的目录，相当于我们在 vhr 中所说的一级菜单，菜单相当于我们在 vhr 中所说的二级菜单。\r\n\r\n当用户从前端登录胜利后，要去动态加载的菜单的时分，就查询 M 和 C 类型的数据即可，F 类型的数据不是菜单项，查询的时分直接过滤掉即可，经过 menu_type 这个字段能够轻松的过滤掉 F 类型的数据。小同伴们想想，F 类型的数据过滤掉之后，剩下的数据不就是一级菜单和二级菜单了，那不就和 vhr 又一样了么！\r\n\r\n\r\n\r\n在 vhr 中，思索到菜单就是只要两级：一级菜单和二级菜单，一级菜单是目录，二级菜单是则是详细的菜单项，没有三级菜单！所以在 vhr 中，查询菜单的时分我直接用了一个一对多的查询，将一级菜单做一的一方，二级菜单做多的一方，这样比拟省事。当然灵敏度差一点，所以在 TienChin 项目中，这块还是用上了递归。\r\n\r\n3.2 菜单接口\r\n\r\n当用户登录胜利之后，会自动恳求 /getRouters 接口来获取菜单信息，我们一同来看下：\r\n\r\n\r\n\r\n/**\r\n\r\n* 获取路由信息\r\n\r\n*\r\n\r\n* @return 路由信息\r\n\r\n*/\r\n\r\n@GetMapping(\"getRouters\")\r\n\r\npublic AjaxResult getRouters() {\r\n\r\n   Long userId = SecurityUtils.getUserId();\r\n\r\n   List<SysMenu> menus = menuService.selectMenuTreeByUserId(userId);\r\n\r\n   return AjaxResult.success(menuService.buildMenus(menus));\r\n\r\n}\r\n\r\n复制代码\r\n\r\n这里的查询实践上分为两个步骤：\r\n\r\n\r\n\r\n依据用户 id 查询到一切的菜单信息，这一步的查询实践上是比拟容易的，就单纯的多张表结合在一同，然后过滤出和当前用户相关并且菜单类型为 M 或者 C 的菜单（类型为 F 的表示按钮，就不要了），查询到菜单信息之后，然后停止一个递归操作，将菜单数据的层级排列出来。\r\n\r\nmenuService.buildMenus 这一步则是将菜单数据专为前端所需求的路由数据。\r\n\r\n\r\n\r\n一共就这两个步骤，我们来逐一停止剖析。\r\n\r\n先来看查询菜单数据。\r\n\r\n\r\n\r\n/**\r\n\r\n* 依据用户ID查询菜单\r\n\r\n*\r\n\r\n* @param userId 用户称号\r\n\r\n* @return 菜单列表\r\n\r\n*/\r\n\r\n@Override\r\n\r\npublic List<SysMenu> selectMenuTreeByUserId(Long userId) {\r\n\r\n   List<SysMenu> menus = null;\r\n\r\n   if (SecurityUtils.isAdmin(userId)) {\r\n\r\n       menus = menuMapper.selectMenuTreeAll();\r\n\r\n   } else {\r\n\r\n       menus = menuMapper.selectMenuTreeByUserId(userId);\r\n\r\n   }\r\n\r\n   return getChildPerms(menus, 0);\r\n\r\n}\r\n\r\n/**\r\n\r\n* 依据父节点的ID获取一切子节点\r\n\r\n*\r\n\r\n* @param list     分类表\r\n\r\n* @param parentId 传入的父节点ID\r\n\r\n* @return String\r\n\r\n*/\r\n\r\npublic List<SysMenu> getChildPerms(List<SysMenu> list, int parentId) {\r\n\r\n   List<SysMenu> returnList = new ArrayList<SysMenu>();\r\n\r\n   for (Iterator<SysMenu> iterator = list.iterator(); iterator.hasNext(); ) {\r\n\r\n       SysMenu t = (SysMenu) iterator.next();\r\n\r\n       // 一、依据传入的某个父节点ID,遍历该父节点的一切子节点\r\n\r\n       if (t.getParentId() == parentId) {\r\n\r\n           recursionFn(list, t);\r\n\r\n           returnList.add(t);\r\n\r\n       }\r\n\r\n   }\r\n\r\n   return returnList;\r\n\r\n}\r\n\r\n/**\r\n\r\n* 递归列表\r\n\r\n*\r\n\r\n* @param list\r\n\r\n* @param t\r\n\r\n*/\r\n\r\nprivate void recursionFn(List<SysMenu> list, SysMenu t) {\r\n\r\n   // 得到子节点列表\r\n\r\n   List<SysMenu> childList = getChildList(list, t);\r\n\r\n   t.setChildren(childList);\r\n\r\n   for (SysMenu tChild : childList) {\r\n\r\n       if (hasChild(list, tChild)) {\r\n\r\n           recursionFn(list, tChild);\r\n\r\n       }\r\n\r\n   }\r\n\r\n}\r\n\r\n/**\r\n\r\n* 得到子节点列表\r\n\r\n*/\r\n\r\nprivate List<SysMenu> getChildList(List<SysMenu> list, SysMenu t) {\r\n\r\n   List<SysMenu> tlist = new ArrayList<SysMenu>();\r\n\r\n   Iterator<SysMenu> it = list.iterator();\r\n\r\n   while (it.hasNext()) {\r\n\r\n       SysMenu n = (SysMenu) it.next();\r\n\r\n       if (n.getParentId().longValue() == t.getMenuId().longValue()) {\r\n\r\n           tlist.add(n);\r\n\r\n       }\r\n\r\n   }\r\n\r\n   return tlist;\r\n\r\n}\r\n\r\n/**\r\n\r\n* 判别能否有子节点\r\n\r\n*/\r\n\r\nprivate boolean hasChild(List<SysMenu> list, SysMenu t) {\r\n\r\n   return getChildList(list, t).size() > 0;\r\n\r\n}\r\n\r\n复制代码\r\n\r\n这里一共触及到五个关键办法，我们来逐一停止剖析：\r\n\r\n\r\n\r\nselectMenuTreeByUserId：这个办法的执行比拟容易，假如当前用户是管理员，那就不用加过滤条件了，直接查询出一切的类型为 M 和 C 的菜单项即可。\r\n\r\ngetChildPerms：这个办法主要是将前面查询出来的菜单数据停止重组，原本都是一个汇合中的数据，如今在该办法中处置成树状，处置的中心逻辑就是调用 recursionFn 办法将之停止递归。\r\n\r\nrecursionFn：这是最为关键的递归办法了，首先调用 getChildList 获取当前菜单项的 children，然后将获取到的 children 设置给当前菜单项，最后还要遍历获取到的 children，假如这个 children 也是有子菜单的，则继续调用 recursionFn 办法停止处置。\r\n\r\ngetChildList：这个是查询某一个菜单的子菜单，这个很容易，假如某一个菜单的 parentId 是当前菜单的 id，那么这个菜单就是当前菜单的子菜单。\r\n\r\nhasChild：这个是判别给定的菜单能否有子菜单，这个逻辑就比拟简单了。\r\n\r\n\r\n\r\n好啦，这个就是整个的查询逻辑，整体上来说是比拟容易的，就是查询 M 和 C 类型的菜单，然后再做一个递归操作，将菜单数据变成一个树状数据。\r\n\r\n但是由于 SysMenu 和前后端所需求的路由数据的字段称号对不上，并且格式参数等都不契合前端的请求，所以还需求再做一个转换，这就是 menuService.buildMenus 所做的事情了：\r\n\r\n/**\r\n\r\n\r\n\r\n构建前端路由所需求的菜单\r\n\r\n*\r\n\r\n@param menus 菜单列表\r\n\r\n@return 路由列表\r\n\r\n*/\r\n\r\n@Override\r\n\r\npublic List<RouterVo> buildMenus(List<SysMenu> menus) {\r\n\r\n\r\n\r\nList<RouterVo> routers = new LinkedList<RouterVo>();\r\n\r\nfor (SysMenu menu : menus) {\r\n\r\n   RouterVo router = new RouterVo();\r\n\r\n   router.setHidden(\"1\".equals(menu.getVisible()));\r\n\r\n   router.setName(getRouteName(menu));\r\n\r\n   router.setPath(getRouterPath(menu));\r\n\r\n   router.setComponent(getComponent(menu));\r\n\r\n   router.setQuery(menu.getQuery());\r\n\r\n   router.setMeta(new MetaVo(menu.getMenuName(), menu.getIcon(), StringUtils.equals(\"1\", menu.getIsCache()), menu.getPath()));\r\n\r\n   List<SysMenu> cMenus = menu.getChildren();\r\n\r\n   if (!cMenus.isEmpty() && cMenus.size() > 0 && UserConstants.TYPE_DIR.equals(menu.getMenuType())) {\r\n\r\n       router.setAlwaysShow(true);\r\n\r\n       router.setRedirect(\"noRedirect\");\r\n\r\n       router.setChildren(buildMenus(cMenus));\r\n\r\n   } else if (isMenuFrame(menu)) {\r\n\r\n       router.setMeta(null);\r\n\r\n       List<RouterVo> childrenList = new ArrayList<RouterVo>();\r\n\r\n       RouterVo children = new RouterVo();\r\n\r\n       children.setPath(menu.getPath());\r\n\r\n       children.setComponent(menu.getComponent());\r\n\r\n       children.setName(StringUtils.capitalize(menu.getPath()));\r\n\r\n       children.setMeta(new MetaVo(menu.getMenuName(), menu.getIcon(), StringUtils.equals(\"1\", menu.getIsCache()), menu.getPath()));\r\n\r\n       children.setQuery(menu.getQuery());\r\n\r\n       childrenList.add(children);\r\n\r\n       router.setChildren(childrenList);\r\n\r\n   } else if (menu.getParentId().intValue() == 0 && isInnerLink(menu)) {\r\n\r\n       router.setMeta(new MetaVo(menu.getMenuName(), menu.getIcon()));\r\n\r\n       router.setPath(\"/\");\r\n\r\n       List<RouterVo> childrenList = new ArrayList<RouterVo>();\r\n\r\n       RouterVo children = new RouterVo();\r\n\r\n       String routerPath = innerLinkReplaceEach(menu.getPath());\r\n\r\n       children.setPath(routerPath);\r\n\r\n       children.setComponent(UserConstants.INNER_LINK);\r\n\r\n       children.setName(StringUtils.capitalize(routerPath));\r\n\r\n       children.setMeta(new MetaVo(menu.getMenuName(), menu.getIcon(), menu.getPath()));\r\n\r\n       childrenList.add(children);\r\n\r\n       router.setChildren(childrenList);\r\n\r\n   }\r\n\r\n   routers.add(router);\r\n\r\n}\r\n\r\nreturn routers;\r\n\r\n}\r\n\r\n复制代码\r\n\r\n从这个办法的执行逻辑上我们能够看到，这里的菜单数据一共分为了四种状况，其实刚好就和我们第一小节所引见的状况相对应。\r\n\r\n整体上来看，分支语句外面设置了组件的最根本的属性。三个分支语句：\r\n\r\n\r\n\r\n第一个分支，处置普通的有父有子的状况。\r\n\r\n第二个分支，处置第一小节第二种状况。\r\n\r\n第三个分支，处置第一小节第三种状况。\r\n\r\n假如三个分支都没进去，那就是第一小节的第四种状况，以及各个子菜单的状况了。\r\n\r\n\r\n\r\n好了，基于这样大的思绪，再来看各个属性的详细设置，就很容易了。\r\n\r\n\r\n\r\n首先是可见性 hidden，这个没啥好说的。\r\n\r\n接下来是菜单的 name 属性，name 属性分为了两种状况：路由的 name 属性是菜单表中的 path 字段值且首字母大写（菜单 1、3、4）；假如在一级菜单中，呈现了一个菜单 C（原本这一级别只要 M），并且还不是外链，那么就设置菜单的 name 为空字符串（相当于此时不需求 name 属性了，对应菜单 2 的状况）。\r\n\r\n接下来是路由的 path，设置 path 的时分也分好种状况，松哥对照着代码来和大家说一下：\r\n\r\n\r\n\r\n/**\r\n\r\n\r\n\r\n获取路由地址\r\n\r\n*\r\n\r\n@param menu 菜单信息\r\n\r\n@return 路由地址\r\n\r\n*/\r\n\r\npublic String getRouterPath(SysMenu menu) {\r\n\r\n\r\n\r\nString routerPath = menu.getPath();\r\n\r\n// 内链翻开外网方式\r\n\r\nif (menu.getParentId().intValue() != 0 && isInnerLink(menu)) {\r\n\r\n   routerPath = innerLinkReplaceEach(routerPath);\r\n\r\n}\r\n\r\n// 非外链并且是一级目录（类型为目录）\r\n\r\nif (0 == menu.getParentId().intValue() && UserConstants.TYPE_DIR.equals(menu.getMenuType())\r\n\r\n       && UserConstants.NO_FRAME.equals(menu.getIsFrame())) {\r\n\r\n   routerPath = \"/\" + menu.getPath();\r\n\r\n}\r\n\r\n// 非外链并且是一级目录（类型为菜单）\r\n\r\nelse if (isMenuFrame(menu)) {\r\n\r\n   routerPath = \"/\";\r\n\r\n}\r\n\r\nreturn routerPath;\r\n\r\n}\r\n\r\n复制代码\r\n\r\na. 首先获取从数据库中查询到的 path 属性。\r\n\r\nb. 假如当前组件不是一级菜单，并且是在内部组件中展现，那么除去这个 path 里边的 http 或者 https（对应菜单 3 的 children 的状况）。\r\n\r\nc. 假如当前组件是一级菜单并且是 M 型并且不是外链，那么就在原有的 path 上加上 / 前缀（对应菜单 1 的一级菜单的 path 状况）。\r\n\r\nd. 假如当前组件是一级菜单，且是 C 型菜单，那么设置 path 为 /（对应菜单 2、3 中一级菜单的 path 状况）。\r\n\r\ne. 其他状况，菜单都是从数据库查到什么返回什么。\r\n\r\n\r\n\r\n接下来是设置前端 component，这个菜单项用哪个 component 组件显现出来。\r\n\r\n\r\n\r\n/**\r\n\r\n\r\n\r\n获取组件信息\r\n\r\n*\r\n\r\n@param menu 菜单信息\r\n\r\n@return 组件信息\r\n\r\n*/\r\n\r\npublic String getComponent(SysMenu menu) {\r\n\r\n\r\n\r\nString component = UserConstants.LAYOUT;\r\n\r\nif (StringUtils.isNotEmpty(menu.getComponent()) && !isMenuFrame(menu)) {\r\n\r\n   component = menu.getComponent();\r\n\r\n} else if (StringUtils.isEmpty(menu.getComponent()) && menu.getParentId().intValue() != 0 && isInnerLink(menu)) {\r\n\r\n   component = UserConstants.INNER_LINK;\r\n\r\n} else if (StringUtils.isEmpty(menu.getComponent()) && isParentView(menu)) {\r\n\r\n   component = UserConstants.PARENT_VIEW;\r\n\r\n}\r\n\r\nreturn component;\r\n\r\n}\r\n\r\n复制代码\r\n\r\na. 首先默许的组件是 Layout（菜单1、2、3、4 的一级菜单）。\r\n\r\nb. 假如配置的时分就有 component，并且当前菜单项也不是外链，那么就运用配置的 component（菜单 1、2 的子菜单状况）。\r\n\r\nc. 假如不是一级菜单（是一个子菜单），并且是一个在当前系统展现的外链，那么就运用 InnerLink 这个组件（这个组件中有一个 iframe 标签能够把外链展现出来，如菜单 4 的子菜单状况）。\r\n\r\nd. 假如配置的时分没有设置组件并且菜单类型是 M（二级菜单中还有三级菜单的状况），那么就设置显现组件为 ParentView。\r\n\r\ncomponent 就分为这几种状况。\r\n\r\n\r\n\r\n接下来就是 query 和 meta 这两个参数就没啥好说的。\r\n\r\n\r\n\r\n接下来就是三个分支的状况了。\r\n\r\n其他属性都比拟容易，我就不啰嗦啦～\r\n-----------------------------------\r\n©著作权归作者所有：来自51CTO博客作者mb62da321250946的原创作品，请联系作者获取转载授权，否则将追究法律责任\r\nSpring Boot思绪梳理\r\nhttps://blog.51cto.com/u_15726907/5504056", "note_img": "uploads/blog/blog.jpeg", "create_time": "2022-07-22T21:26:02.353", "update_time": "2022-07-22T21:26:02.353", "click_num": 2, "love_num": 0, "user": 8}}, {"model": "blog.note", "pk": 10, "fields": {"title": "异步IO", "desc": "暂无简介", "content": "在IO编程一节中，我们已经知道，CPU的速度远远快于磁盘、网络等IO。在一个线程中，CPU执行代码的速度极快，然而，一旦遇到IO操作，如读写文件、发送网络数据时，就需要等待IO操作完成，才能继续进行下一步操作。这种情况称为同步IO。\r\n\r\n在IO操作的过程中，当前线程被挂起，而其他需要CPU执行的代码就无法被当前线程执行了。\r\n\r\n因为一个IO操作就阻塞了当前线程，导致其他代码无法执行，所以我们必须使用多线程或者多进程来并发执行代码，为多个用户服务。每个用户都会分配一个线程，如果遇到IO导致线程被挂起，其他用户的线程不受影响。\r\n\r\n多线程和多进程的模型虽然解决了并发问题，但是系统不能无上限地增加线程。由于系统切换线程的开销也很大，所以，一旦线程数量过多，CPU的时间就花在线程切换上了，真正运行代码的时间就少了，结果导致性能严重下降。\r\n\r\n由于我们要解决的问题是CPU高速执行能力和IO设备的龟速严重不匹配，多线程和多进程只是解决这一问题的一种方法。\r\n\r\n另一种解决IO问题的方法是异步IO。当代码需要执行一个耗时的IO操作时，它只发出IO指令，并不等待IO结果，然后就去执行其他代码了。一段时间后，当IO返回结果时，再通知CPU进行处理。\r\n\r\n可以想象如果按普通顺序写出的代码实际上是没法完成异步IO的：\r\n```python\r\ndo_some_code()\r\nf = open('/path/to/file', 'r')\r\nr = f.read() # <== 线程停在此处等待IO操作结果\r\n# IO操作完成后线程才能继续执行:\r\ndo_some_code(r)\r\n```\r\n所以，同步IO模型的代码是无法实现异步IO模型的。\r\n\r\n异步IO模型需要一个消息循环，在消息循环中，主线程不断地重复“读取消息-处理消息”这一过程\r\n```python\r\nloop = get_event_loop()\r\nwhile True:\r\n    event = loop.get_event()\r\n    process_event(event)\r\n```\r\n消息模型其实早在应用在桌面应用程序中了。一个GUI程序的主线程就负责不停地读取消息并处理消息。所有的键盘、鼠标等消息都被发送到GUI程序的消息队列中，然后由GUI程序的主线程处理。\r\n\r\n由于GUI线程处理键盘、鼠标等消息的速度非常快，所以用户感觉不到延迟。某些时候，GUI线程在一个消息处理的过程中遇到问题导致一次消息处理时间过长，此时，用户会感觉到整个GUI程序停止响应了，敲键盘、点鼠标都没有反应。这种情况说明在消息模型中，处理一个消息必须非常迅速，否则，主线程将无法及时处理消息队列中的其他消息，导致程序看上去停止响应。\r\n\r\n消息模型是如何解决同步IO必须等待IO操作这一问题的呢？当遇到IO操作时，代码只负责发出IO请求，不等待IO结果，然后直接结束本轮消息处理，进入下一轮消息处理过程。当IO操作完成后，将收到一条“IO完成”的消息，处理该消息时就可以直接获取IO操作结果。\r\n\r\n在“发出IO请求”到收到“IO完成”的这段时间里，同步IO模型下，主线程只能挂起，但异步IO模型下，主线程并没有休息，而是在消息循环中继续处理其他消息。这样，在异步IO模型下，一个线程就可以同时处理多个IO请求，并且没有切换线程的操作。对于大多数IO密集型的应用程序，使用异步IO将大大提升系统的多任务处理能力。", "note_img": "uploads/blog/2022/07/23/blog_9.jpeg", "create_time": "2022-07-22T21:30:34.419", "update_time": "2022-07-23T16:57:24.261", "click_num": 4, "love_num": 0, "user": 1}}, {"model": "blog.note", "pk": 11, "fields": {"title": "虚拟环境venv", "desc": "暂无简介", "content": "在开发Python应用程序的时候，系统安装的Python3只有一个版本：3.10。所有第三方的包都会被pip安装到Python3的site-packages目录下。\r\n\r\n如果我们要同时开发多个应用程序，那这些应用程序都会共用一个Python，就是安装在系统的Python 3。如果应用A需要jinja 2.7，而应用B需要jinja 2.6怎么办？\r\n\r\n这种情况下，每个应用可能需要各自拥有一套“独立”的Python运行环境。venv就是用来为一个应用创建一套“隔离”的Python运行环境。\r\n\r\n首先，我们假定要开发一个新的项目project101，需要一套独立的Python运行环境，可以这么做：\r\n\r\n第一步，创建目录，这里把venv命名为proj101env，因此目录名为proj101env：\r\n```bash\r\n~$ mkdir proj101env\r\n~$ cd proj101env/\r\nproj101env$\r\n```\r\n第二步，创建一个独立的Python运行环境\r\n```bash\r\nproj101env$ python3 -m venv\r\n```\r\n查看当前目录，可以发现有几个文件夹和一个pyvenv.cfg文件：\r\nproj101env$ ls\r\nbin  include  lib  pyvenv.cfg\r\n命令python3 -m venv <目录>就可以创建一个独立的Python运行环境。观察bin目录的内容，里面有python3、pip3等可执行文件，实际上是链接到Python系统目录的软链接。\r\n\r\n继续进入bin目录，Linux/Mac用source activate，Windows用activate.bat激活该venv环境：\r\n```bash\r\nproj101env$ cd bin\r\nbin$ source activate\r\n(proj101env) bin$\r\n```\r\n注意到命令提示符变了，有个(proj101env)前缀，表示当前环境是一个名为proj101env的Python环境。\r\n\r\n下面正常安装各种第三方包，并运行python命令：\r\n```bash\r\n(proj101env) bin$ pip3 install jinja2\r\n...\r\nSuccessfully installed jinja2-xxx\r\n(proj101env) bin$ python3\r\n>>> import jinja2\r\n>>> exit()\r\n```\r\n在venv环境下，用pip安装的包都被安装到proj101env这个环境下，具体目录是proj101env/lib/python3.x/site-packages，因此，系统Python环境不受任何影响。也就是说，proj101env环境是专门针对project101这个应用创建的。\r\n\r\n退出当前的proj101env环境，使用deactivate命令：\r\n```bash\r\n(proj101env) bin$ deactivate\r\nbin$\r\n```\r\n此时就回到了正常的环境，现在pip或python均是在系统Python环境下执行。\r\n\r\n完全可以针对每个应用创建独立的Python运行环境，这样就可以对每个应用的Python环境进行隔离。\r\n\r\nvenv是如何创建“独立”的Python运行环境的呢？原理很简单，就是把系统Python链接或复制一份到venv的环境，用命令source activate进入一个venv环境时，venv会修改相关环境变量，让命令python和pip均指向当前的venv环境。\r\n\r\n如果不再使用某个venv，例如proj101env，删除它也很简单。首先确认该venv没有处于“激活”状态，然后直接把整个目录proj101env删掉就行。\r\n\r\n小结\r\nvenv为应用提供了隔离的Python运行环境，解决了不同应用间多版本的冲突问题。", "note_img": "uploads/blog/blog.jpeg", "create_time": "2022-07-22T21:34:39.432", "update_time": "2022-07-22T21:34:39.432", "click_num": 10, "love_num": 0, "user": 8}}, {"model": "blog.note", "pk": 12, "fields": {"title": "测试博客", "desc": "暂无简介", "content": "![](/media/editor\\blog_3_20220723173437079915.jpeg)测试的", "note_img": "uploads/blog/2022/07/23/blog_12.jpeg", "create_time": "2022-07-22T23:31:53.455", "update_time": "2022-07-23T17:35:03.630", "click_num": 2, "love_num": 0, "user": 9}}, {"model": "blog.note", "pk": 14, "fields": {"title": "测试表情", "desc": "暂无简介", "content": "测试\r\n\r\n:stuck_out_tongue: :stuck_out_tongue:", "note_img": "uploads/blog/blog.jpeg", "create_time": "2022-07-23T14:06:03.231", "update_time": "2022-07-23T17:43:47.130", "click_num": 9, "love_num": 0, "user": 9}}, {"model": "blog.note", "pk": 15, "fields": {"title": "django多对多", "desc": "暂无简介", "content": "# article.tags = request.POST['tags'] #这样写无效\r\n#关键是多对多的标签要注意\r\ntags_post=request.POST['tags'] #拿到的是带,的字符串\r\ntags_list=tags_post.split(',')  #分割为list\r\n\r\n\r\n\r\narticle.tags.set(tags_list) #注意参数是个标签组成的列表\r\narticle.save()\r\n参考：\r\n https://blog.csdn.net/alexander068/article/details/119724017\r\nDjango多对多数据增删改查 http://t.zoukankan.com/17vv-p-11723372.html'", "note_img": "uploads/blog/2022/07/23/blog_7.jpeg", "create_time": "2022-07-23T16:55:25.973", "update_time": "2022-07-23T16:56:37.004", "click_num": 1, "love_num": 0, "user": 9}}, {"model": "blog.note", "pk": 16, "fields": {"title": "django 实现电子支付功能", "desc": "暂无简介", "content": "思路：调用第三方支付 API 接口实现支付功能。本来想用支付宝来实现第三方网站的支付功能的，但是在实际操作中发现支付宝没有 Python 接口，网上虽然有他人二次封装的的 Python 接口，但是对我这个小白白来说上手还是有点难度，后来发现 PayPal 有现成的 Django 模块，想着以学习的目的来实现这一功能（其实还是自己辣鸡），就决定以 PayPal 的电子支付功能来练手。\r\n安装 PayPal 的 Django 模块：django-paypal\r\n```python\r\n# 此付款机制作为测试用\r\nPAYPAL_TEST = True\r\n# 设置收款的 PayPal 电子邮件账户\r\nPAYPAL_REVEIVER_EMAIL = 'your email'\r\n\r\n```\r\n同步数据库操作\r\npayPal 付款操作，建立含有正确数据的付款按钮\r\n\r\n```python\r\n@login_required\r\ndef payment(request, order_id):\r\n    all_categories = models.Category.objects.all()\r\n    try:\r\n        order = models.Order.objects.get(id=order_id)\r\n    except:\r\n        messages.add_message(request, messages.WARNING, \"订单编号错误，无法处理付款。\")\r\n        return redirect('/myorders/')\r\n    all_order_items = models.OrderItem.objects.filter(order=order)\r\n    items = list()\r\n    total = 0\r\n    for order_item in all_order_items:\r\n        t = dict()\r\n        t['name'] = order_item.product.name\r\n        t['price'] = order_item.product.price\r\n        t['quantity'] = order_item.quantity\r\n        t['subtotal'] = order_item.product.price * order_item.quantity\r\n        total = total + order_item.product.price\r\n        items.append(t)\r\n\r\n    host = request.get_host()\r\n    paypal_dict = {\r\n        \"business\": settings.PAYPAL_REVEIVER_EMAIL,\r\n        \"amount\": total,\r\n        \"item_name\": \"迷你小电商商品编号:{}\".format(order_id),\r\n        \"invoice\": \"invoice-{}\".format(order_id),\r\n        \"currency_code\": 'CNY',\r\n        \"notify_url\": \"http://{}{}\".format(host, reverse('paypal-ipn')),\r\n        \"return_url\": \"http://{}/done/\".format(host),\r\n        \"cancel_return\": \"http://{}/canceled/\".format(host),\r\n        }\r\n    paypal_form = PayPalPaymentsForm(initial=paypal_dict)\r\n    template = get_template('payment.html')\r\n    html = template.render(context=locals(), request=request)\r\n    return HttpResponse(html)\r\n```\r\n由于用到了 django-paypal 提供的 PayPalPaymentForm 类。因此在 views.py 的前面也要导入这个类。另外，因为用到了 settings.py 中的常数，所以也要导入 settings，语句如下：\r\n```python\r\nfrom django.conf import settings\r\nfrom paypal.standard.forms import PayPalPaymentsForm\r\nfrom django.core.urlresolvers import reverse\r\n```\r\n付款完成\r\n```python\r\n@csrf_exempt    #csrf 验证\r\ndef payment_done(request):\r\n    template = get_template('payment_done.html')\r\n    html = template.render(context=locals(), request=request)\r\n    return HttpResponse(html)\r\n```\r\n取消付款\r\n```python\r\n@csrf_exempt\r\ndef payment_canceled(request):\r\n    template = get_template('payment_canceled.html')\r\n    html = template.render(context=locals(), request=request)\r\n    return HttpResponse(html)\r\n```\r\nPayPal 付款页面\r\n```html\r\n<!-- payment.html (mshop project) -->\r\n{% extends \"base.html\" %}\r\n{% block title %}选择您的付款方式{% endblock %}\r\n{% block content %}\r\n<div class='container'>\r\n{% for message in messages %}\r\n    <div class='alert alert-{{message.tags}}'>{{ message }}</div>\r\n{% endfor %}\r\n    <div class='row'>\r\n        <div class='col-md-12'>\r\n            <div class='panel panel-default'>\r\n                <div class='panel-heading' align=center>\r\n                    <h3>欢迎光临迷你小电商</h3>\r\n                        {% if user.socialaccount_set.all.0.extra_data.name %}\r\n                            {{user.socialaccount_set.all.0.extra_data.name}}<br/>\r\n                            <img src='{{user.socialaccount_set.all.0.get_avatar_url}}' width='100'>\r\n                        {% else %}\r\n                            Welcome: {{ user.username }}\r\n                        {% endif %}\r\n                </div>\r\n            </div>\r\n        </div>\r\n    </div>\r\n    <div class='row'>\r\n        <div class='col-sm-12'>\r\n            <div class='panel panel-info'>\r\n                <div class='panel panel-heading'>\r\n                    <h4>在线付款（订单编号：{{order.id}}）</h4>\r\n                </div>\r\n                <div class='panel panel-body'>\r\n                    {% for item in items %}\r\n                    {% if forloop.first %}\r\n                    <table border=1>\r\n                        <tr>\r\n                            <td width=300 align=center>产品名称</td>\r\n                            <td width=100 align=center>单价</td>\r\n                            <td width=100 align=center>数量</td>\r\n                            <td width=100 align=center>小计</td>\r\n                        </tr>\r\n                    {% endif %}\r\n                        <div class='listgroup'>\r\n                            <div class='listgroup-item'>\r\n                                <tr>\r\n                                    <td>{{ item.name }}</td>\r\n                                    <td align=right>{{ item.price }}</td>\r\n                                    <td align=center>{{ item.quantity }}</td>\r\n                                    <td align=right>{{ item.subtotal }}</td>\r\n                                </tr>\r\n                            </div>\r\n                        </div>\r\n                    {% if forloop.last %}\r\n                    </table>\r\n                    {% endif %}\r\n                    {% empty %}\r\n                        <em>此订单是空的</em>\r\n                    {% endfor %}\r\n                    \r\n                    {{ paypal_form.render }}\r\n                </div>\r\n                <div class='panel panel-footer'>\r\n                    NT$:{{ total }}元\r\n                </div>\r\n            </div>\r\n        </div>\r\n    </div>\r\n</div>\r\n{% endblock %}\r\n```\r\n\r\n取消付款页面\r\n```html\r\n<!-- payment_canceled.html (mshop project) -->\r\n{% extends \"base.html\" %}\r\n{% block title %}PayPal 付款取消通知{% endblock %}\r\n{% block content %}\r\n<div class='container'>\r\n{% for message in messages %}\r\n    <div class='alert alert-{{message.tags}}'>{{ message }}</div>\r\n{% endfor %}\r\n    <div class='row'>\r\n        <div class='col-md-12'>\r\n            <div class='panel panel-default'>\r\n                <div class='panel-heading' align=center>\r\n                    <h3>欢迎光临迷你小电商</h3>\r\n                        {% if user.socialaccount_set.all.0.extra_data.name %}\r\n                            {{user.socialaccount_set.all.0.extra_data.name}}<br/>\r\n                            <img src='{{user.socialaccount_set.all.0.get_avatar_url}}' width='100'>\r\n                        {% else %}\r\n                            Welcome: {{ user.username }}\r\n                        {% endif %}\r\n                </div>\r\n            </div>\r\n        </div>\r\n    </div>\r\n    <div class='row'>\r\n        <div class='col-sm-12'>\r\n            <div class='panel panel-info'>\r\n                <div class='panel panel-heading'>\r\n                    <h4>您刚刚取消了PayPal的付款</h4>\r\n                </div>\r\n                <div class='panel panel-body'>\r\n                    <p>请再次检查您的付款，或是返回<a href='/myorders/'>我的订单</a>选用其它付款方式。</p>\r\n                </div>\r\n                <div class='panel panel-footer'>\r\n                </div>\r\n            </div>\r\n        </div>\r\n    </div>\r\n</div>\r\n{% endblock %}\r\n```\r\nPayPal 在处理完在线付款流程后会另外发送一个 HTTP 数据给我们的网站，我们应该编写一个处理这个信号的函数，更改我们数据库中的内容，为了确保我们设置的监听函数可以被系统加载且保持运行，在 views.py 的同级目录中建立一个名为 signal.py 文件。\r\n\r\n```python\r\nfrom mysite import models\r\nfrom paypal.standard.models import ST_PP_COMPLETED\r\nfrom paypal.standard.ipn.signals import valid_ipn_received\r\n\r\ndef payment_notfication(sender, **kwargs):\r\n    ipn_obj = sender\r\n    if ipn_obj.payment_status == ST_PP_COMPLETED:\r\n        order_id = ipn_obj.invocie.split('-')[-1]\r\n        order = models.Order.objects.get(id = order_id)\r\n        order_id.paid = True\r\n        order.save()\r\n\r\nvalid_ipn_received.connect(payment_notfication)\r\n```\r\n同一文件夹下再创建一个名为 apps.py 的文件，确保上述编写的函数在一开始的时候就能够加载。\r\n```python\r\nfrom django.apps import AppConfig\r\n\r\n\r\nclass PaymentConfig(AppConfig):\r\n    name = 'mysite'\r\n    verbose_name = 'Mysite'\r\n\r\n    def ready(self):\r\n        import mysite.signal\r\n```\r\n在同一文件夹下的 __init__.py 中加入以下语句，确保我们在应用程序初始化加载的时候，可以把我们自定义的应用程序环境设置成能够加载自定义的工作\r\n\r\n```python\r\ndefault_app_config = 'mysite.apps.PaymentConfig'\r\n```\r\n通过上述设置，我们的网站已经可以正确地接受订单并使用 PayPal 付款了，我们可以在 PayPal 开发者网站（https://developer.paypal.com/）申请一个测试账号来进行付款测试。\r\n点击进入 dashboard 界面，点击 sandbox 下的 account 选项，我们可以在此创建一个测试账号。![](http://image.baizhud.com/images/mytent/2022-06-05/1654416267cC16544m16A267.png)\r\n\r\n点击创建账号下的 profile 选项，进入详情页，设置此账号的密码，并将 Payment Review 的功能设置为 Off。\r\n![](http://image.baizhud.com/images/mytent/2022-06-05/16544162671654401626H1h7.png)\r\n\r\n接下来我们便可以在我们的网站中使用这个测试账号付款了，点击前往付款，调用 payment 函数，加载含有正确数据的付款按钮，点击后便跳转到 paypal 的沙盒付款页面，我们在其中填入我们之前建立好的测试账号信息，登录后便可以付款了。\r\n![](http://image.baizhud.com/images/mytent/2022-06-05/1654416267165441a6b26rx7.png)\r\n付款成功后便返回我们之前编写好的付款成功页面。\r\n![](http://image.baizhud.com/images/mytent/2022-06-05/165441626719w654416p2d67.png)\r\n注意：中国大陆的 paypal 账号不能用来测试实际支付，需要大陆以外的 paypal 账户才可测试实际支付。（真是坑。。。）\r\n\r\n不然付款的时候会出现下列界面。![](http://image.baizhud.com/images/mytent/2022-06-05/165441626716q54416RI26A7.png)\r\n到这里，我们的付款便已经成功了，但是 PayPal 无法将支付状态通知发送到我们的应用，这是由于我们的项目运行在外部无法访问的 127.0.0.1 上。我们使用 Ngrok 来实现因特网访问开发环境。\r\n在 Ngrok 官网 https://ngrok.com/ 下载解压文件并关联账号后，运行下列命令。\r\n./ngrok http 8000\r\n这个命令将在 8000 端口为本地主机创建一个通道并为其设置一个网![](http://image.baizhud.com/images/mytent/2022-06-05/165441626716544qb162oq67.png)络可以访问的主机名称，得到以下输出：\r\n\r\n![](这个命令将在 8000 端口为本地主机创建一个通道并为其设置一个网络可以访问的主机名称，得到以下输出：)\r\n\r\n我们可以通过访问 Forwarding 中的网址来连接我们构建在本地的网站。\r\n\r\n然后付款后便能在自己本地网站的后台管理看到 paypal ipn 的信息，我这里显示的状态是 pending，按理来说应该是 completed ，可能 paypal 设置中需要更改，这样的话需要将 signal.py 中 ST_PP_COMPLETED 修改为 ST_PP_PENDING，这样 signal.py 便能正常处理 paypal 返回的信息，将订单状态更改为已完成。![](http://image.baizhud.com/images/mytent/2022-06-05/1654416267516e5441n626J7.png)\r\n至此，我们便完成了调用 paypal 实现第三方网站支付的功能。", "note_img": "uploads/blog/blog.jpeg", "create_time": "2022-07-23T17:19:10.329", "update_time": "2022-07-23T17:19:10.329", "click_num": 1, "love_num": 0, "user": 9}}, {"model": "blog.note", "pk": 17, "fields": {"title": "解决Django3使用editormd上传图片后前端页面未显示后端传回的URL", "desc": "暂无简介", "content": "解决Django3使用editormd上传图片后前端页面未显示后端传回的URL\r\n导致这种情况的原因可能有：\r\n一、editormd是使用POST方法提交的数据，需要对views.py中处理图片上传的函数使用@csrf_exempt解除CSRF验证(注意看控制台的输出，如果未解除验证会报错)。当然也可以修改editormd的源码在前端添加csrf验证。\r\n\r\n二、使用@xframe_options_sameorigin解决iframe拒绝问题(在网上看到的配置editormd的教程里大多没提到这点)。如果是这个原因导致的，在chrome浏览器中的右键–>检查在console中会显示Refused to display 'http://127.0.0.1:8000/ in a frame because it set 'X-Frame-Option‘之类的错误。此时只需要在views.py中对应的处理函数前加上@xframe_options_sameorigin装饰器即可。至于原因已经有前人详细的讲解过了，下面是参考链接：\r\n\r\nDjango 报错 Refused to display 'http://127.0.0.1:8000/ in a frame because it set 'X-Frame-Option\r\ndjango3 Refused to display ‘url‘ in a frame because it set ‘X-Frame-Options‘ to ‘deny‘\r\ndjango解决frame拒绝问题\r\nDjango的X-Frame-Options设置\r\n三、注意从request中取值的方式,使用request.FILES[‘editormd-image-file’]或者是request.FILES.get(‘editormd-image-file’,None)。注意返回值的格式，成功就返回{‘success’:1,‘message’:’’,url:’’}失败就返回{‘success’:0,‘message’:’’}\r\n# 下面给出大概的参考代码\r\n```python\r\nfrom django.views.decorators.clickjacking import xframe_options_sameorigin\r\nfrom django.views.decorators.csrf import csrf_exempt\r\n\r\n@csrf_exempt\r\n@xframe_options_sameorigin\r\ndef upload_image(request):\r\n\tif requst.method=='POST':\r\n\t\tdata = {'success': 0, 'message': '图片上传失败'}\r\n\t\timage = request.FILES.get('editormd-image-file', None)\r\n\t\tif image:\r\n\t\t\t# 这里做图片存储的工作\r\n\t\t\timage_url = ''  # 连接到图片位置的url\r\n\t\t\tdata = {'success': 1, 'message': '图片上传成功', 'url': image_url}\r\n\t\treturn JsonResponse(data, content_type=\"text/html\")\r\n\r\n```\r\n\r\n原因：django3 Refused to display ‘url‘ in a frame because it set ‘X-Frame-Options‘ to ‘deny‘\r\n简单粗暴的做法就是在settings中将中间件给注释掉！\r\n```python\r\nMIDDLEWARE = [\r\n    'apps.blog.middleware.user_id.UserIDMiddleware',\r\n    'django.middleware.security.SecurityMiddleware',\r\n    'django.contrib.sessions.middleware.SessionMiddleware',\r\n    'django.middleware.common.CommonMiddleware',\r\n    'django.middleware.csrf.CsrfViewMiddleware',\r\n    'django.contrib.auth.middleware.AuthenticationMiddleware',\r\n    'django.contrib.messages.middleware.MessageMiddleware',\r\n    # 'django.middleware.clickjacking.XFrameOptionsMiddleware',#这个必定成功\r\n]\r\n```\r\n其他：指定视图函数不设置X-Frame-Options\r\n\r\n@xframe_options_sameorigin\r\ndef up():\r\nxx\r\n\r\n参考：https://blog.csdn.net/a1007720052/article/details/107342613/\r\nhttps://blog.csdn.net/a1007720052/article/details/107342613/![](/media/editor\\屏幕截图 2022-07-23 174230_20220723174258545692.jpg)", "note_img": "uploads/blog/blog.jpeg", "create_time": "2022-07-23T17:43:00.807", "update_time": "2022-07-23T17:43:00.807", "click_num": 3, "love_num": 0, "user": 9}}, {"model": "blog.note", "pk": 18, "fields": {"title": "gly2博客发现的还未解决的问题", "desc": "暂无简介", "content": "1.域名使用本地公网ip解析后无法访问：智能natapp内网穿透\r\n2.手机访问的话打开表情等编辑器超出手机屏幕范围，需要前端优化\r\n3.服务器windows2012换端口后访问失败", "note_img": "uploads/blog/blog.jpeg", "create_time": "2022-07-23T19:38:36.809", "update_time": "2022-08-04T18:33:41.864", "click_num": 1, "love_num": 0, "user": 10}}, {"model": "blog.note", "pk": 19, "fields": {"title": "redis", "desc": "暂无简介", "content": "redis安装后\r\n配置密码需要redis的conf文件，添加requirepass xxxx\r\ndjango 2,3都可以\r\ndjango下使用redis的两个方式：\r\n1 直接redis\r\n2.pip install django-redis\r\nsettings配置：# 配置数据库缓存使用redis\r\n```python\r\n# 参考http://t.zoukankan.com/wsongl-p-14463782.html\r\nCACHES = {\r\n    'default': {\r\n        'BACKEND': 'django_redis.cache.RedisCache',\r\n        'LOCATION': 'redis://127.0.0.1:6379', #可以带/0 /1等表示指定数据库\r\n        'OPTIONS': {\r\n            'CLIENT_CLASS': 'django_redis.client.DefaultClient',\r\n            'CONNECTION_POOL_KWARGS': {\r\n                'max_connections': 1000\r\n            },\r\n            'PASSWORD': '123456', # 如果有设置了redis-server密码在这里设置\r\n        }\r\n    }\r\n}\r\n```", "note_img": "uploads/blog/blog.jpeg", "create_time": "2022-07-24T20:01:00.484", "update_time": "2022-07-24T20:01:00.484", "click_num": 0, "love_num": 0, "user": 10}}, {"model": "blog.note", "pk": 20, "fields": {"title": "django静态文件404", "desc": "暂无简介", "content": "# 原因1：路径不对\r\n配置settings\r\n```python\r\n# 当运行 python manage.py collectstatic\r\n# 用来将所有 STATICFILES_DIRS 中所有文件夹中的文件，以及各app中的static中的文件，都复制到STATIC_ROOT路径里\r\n#集中之后，方便部署\r\n# STATIC_ROOT=os.path.join(BASE_DIR,\"static/\")#错误\r\nSTATIC_ROOT=os.path.join(BASE_DIR,\"/static/\")#正确,官方写法\r\n# 结果141 static files copied to 'F:\\static'.\r\n\r\n# STATIC_ROOT=os.path.join(BASE_DIR,\"collectstatic\")#个人写法\r\n#141 static files copied to 'F:\\pythonpic52projects\\52projects\\16.djangobetter\\mysite\\collectstatic'.\r\n```\r\n# 原因2\r\ndebug=False\r\n可以改为true,或者强制加载\r\nPS: 有时候你会发现, debug=False, 好像有 css. 这是因为如果你先 debug=True, 刷新页面(此时加载了 css), 再 debug=False, 刷新页面会发现还有 css, 这是因为页面有缓存, 还没有及时清理. 使用清缓存刷新(win 下时 ctrl+F5, mac 下是 cmd+shift+R), 就会发现 css 没了\r\n**如果想 debug=False 仍能有 css, 最简单就是\r\npython manage.py runserver –insecure**\r\n\r\n最后\r\n如果不想每次在模版中加载静态文件都使用 load 加载static 标签，那么可以在 settings.py 中的TEMPLATES/OPTIONS 添加 'builtins'：['django.templatetags.static']，这样以后在模版中就可以直接使用 static 标签，而不用手动的 load 了。\r\n\r\n'builtins': ['django.templatetags.static']", "note_img": "uploads/blog/blog.jpeg", "create_time": "2022-07-24T20:10:10.792", "update_time": "2022-07-24T20:10:10.792", "click_num": 0, "love_num": 0, "user": 10}}, {"model": "blog.note", "pk": 21, "fields": {"title": "celery", "desc": "暂无简介", "content": "# 1.安装celery\r\npip install celery\r\n\r\n不需要乱七八糟的djang-celery等\r\ndjango3需要celery>=4.0\r\npip install celery==4.4.2\r\npip install eventlet # celery 4.0+版本以后不支持在windows运行，还需额外安装eventlet库\r\n指定清华源 -i https://pypi.tuna.tsinghua.edu.cn/simple\r\n# 2.配置\r\n参考官网\r\n、https://docs.celeryq.dev/en/v4.4.7/django/first-steps-with-django.html\r\n\r\n或者参考https://blog.csdn.net/weixin_39980711/article/details/110437598?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_title~default-1-110437598-blog-105562213.pc_relevant_multi_platform_whitelistv1&spm=1001.2101.3001.4242.2&utm_relevant_index=4\r\nsettings配置\r\n```python\r\n#celery配置 4.4.2\r\n# 参考https://blog.csdn.net/weixin_39980711/article/details/110437598?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_title~default-1-110437598-blog-105562213.pc_relevant_multi_platform_whitelistv1&spm=1001.2101.3001.4242.2&utm_relevant_index=4\r\n#celery默认也是有自己的配置文件的，名为celeryconfig.py, 但由于管理多个配置文件很麻烦，我们把celery的配置参数也写在django的配置文件里。\r\n# 配置celery时区，默认时UTC。\r\nif USE_TZ:\r\n    timezone = TIME_ZONE\r\n\r\n# celery配置redis作为broker。redis有16个数据库，编号0~15，这里使用第1个。如果有密码带上\r\nbroker_url = 'redis://127.0.0.1:6379/1'\r\n\r\n# 设置存储结果的后台\r\nresult_backend = 'redis://127.0.0.1:6379/1'\r\n\r\n# 可接受的内容格式\r\naccept_content = [\"json\"]\r\n# 任务序列化数据格式\r\ntask_serializer = \"json\"\r\n# 结果序列化数据格式\r\nresult_serializer = \"json\"\r\n\r\n# 可选参数：给某个任务限流\r\n# task_annotations = {'tasks.my_task': {'rate_limit': '10/s'}}\r\n\r\n# 可选参数：给任务设置超时时间。超时立即中止worker\r\n# task_time_limit = 10 * 60\r\n\r\n# 可选参数：给任务设置软超时时间，超时抛出Exception\r\n# task_soft_time_limit = 10 * 60\r\n\r\n# 可选参数：如果使用django_celery_beat进行定时任务\r\n# beat_scheduler = \"django_celery_beat.schedulers:DatabaseScheduler\"\r\n\r\n# 更多选项见\r\n# https://docs.celeryproject.org/en/stable/userguide/configuration.html\r\n\r\n```\r\n在settings同目录下新建celery.py\r\n```python\r\nfrom __future__ import absolute_import, unicode_literals #从未来导入绝对导入，这样我们的 celery.py模块就不会与库发生冲突：必须第一行\r\nimport os\r\nfrom celery import Celery\r\n\r\n# 指定Django默认配置文件模块\r\nfrom mysite import settings\r\n\r\n#设置默认DJANGO_SETTINGS_MODULEcelery命令行程序的环境变量\r\nos.environ.setdefault('DJANGO_SETTINGS_MODULE', 'mysite.settings')\r\n\r\n# 为我们的项目mysite创建一个Celery实例。这里不指定broker容易出现错误。\r\napp = Celery('mysite', broker='redis://127.0.0.1:6379/1')  #raise errorredis.exceptions.AuthenticationError: Authentication required.\r\n\r\n\r\n\r\n# 这里指定从django的settings.py里读取celery配置\r\napp.config_from_object('django.conf:settings')\r\n\r\n\r\n# 加载所有 settings下的app中包含的 tasks,自动从所有已注册的django app中加载任务\r\napp.autodiscover_tasks()\r\n# app.autodiscover_tasks(lambda: settings.INSTALLED_APPS)\r\n\r\n# 用于测试的异步任务\r\n@app.task(bind=True)\r\ndef debug_task(self):\r\n    print('Request: {0!r}'.format(self.request))\r\n\r\n```\r\n在__init__.py\r\n添加\r\n```python\r\nfrom __future__ import absolute_import, unicode_literals\r\nimport pymysql\r\npymysql.install_as_MySQLdb() # 在settings.py同目录下的__init__.py中增加pymsql代码\r\n\r\n# coding:utf-8\r\n\r\n\r\n# 引入celery实例对象,确保项目启动时即加载Celery实例\r\nfrom .celery import app as celery_app\r\n\r\n__all__ = ('celery_app',)\r\n```\r\n不包含23句，那个是pymysql的配置\r\n\r\n\r\n\r\n\r\n测试：启动redisserver后，myproject改为项目名\r\nCelery -A myproject worker -l info -P eventlet\r\n成功结果：    ^![](/media/editor\\屏幕截图 2022-07-24 210744_20220724210811300009.jpg)\r\n可能出现的\r\n错误1：\r\nError:\r\nUnable to load celery application.\r\nThe module myproject was not found.\r\n解决：需要在项目目录下启动，官方文档参考https://docs.celeryq.dev/en/v4.4.7/django/first-steps-with-django.html\r\n后续出现错误：2    from __future__ import absolute_import, unicode_literals\r\nSyntaxError: from __future__ imports must occur at the beginning of the file\r\n必须放在第一行\r\n后续错误3：redis密码错误，设置redis无密码或者设置celeryconfig里broker带redis密码\r\n参考：https://blog.csdn.net/weixin_46043193/article/details/121747173?spm=1001.2101.3001.6650.3&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-3-121747173-blog-108699641.pc_relevant_multi_platform_whitelistv1&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-3-121747173-blog-108699641.pc_relevant_multi_platform_whitelistv1&utm_relevant_index=6", "note_img": "uploads/blog/blog.jpeg", "create_time": "2022-07-24T21:13:09.674", "update_time": "2022-07-24T21:13:09.674", "click_num": 0, "love_num": 0, "user": 10}}, {"model": "blog.note", "pk": 22, "fields": {"title": "异步发送邮件", "desc": "暂无简介", "content": "django使用celery来实现异步\r\n\r\n使用celery来异步发送邮件\r\n\r\n新建tasks.py\r\n配置好celery和redis\r\n写入任务函数\r\n```python\r\n@shared_task\r\ndef send_pwd_email(ran_str_pwd='',to_email=''):\r\n    subject = \"密码重置邮件\"\r\n    message=\"用户您好，您的新随机登录密码是: {} ,请按照大小写输入空格间的6位内容进行登录\".format(ran_str_pwd)\r\n    receiver=[to_email]\r\n    sender=EMAIL_HOST_USER\r\n    mail.send_mail(\r\n    subject=subject,  # 题目\r\n    message=message,  # 消息内容\r\n    from_email=sender,  # 发送者[当前配置邮箱]\r\n    recipient_list=receiver,  # 接收者邮件列表\r\n    )\r\n\r\n```\r\n\r\n在views.py里调用\r\n```python\r\ndef xxx(request):\r\n\t....\r\n\tsend_pwd_email.delay(xx,xx)\r\n\treturn render(....)\r\n```\r\n好处：\r\n直接返回return,邮件交给异步任务去做，减少阻塞", "note_img": "uploads/blog/blog.jpeg", "create_time": "2022-07-28T23:47:42.048", "update_time": "2022-08-04T18:29:50.395", "click_num": 0, "love_num": 0, "user": 10}}, {"model": "blog.note", "pk": 25, "fields": {"title": "django原生drf", "desc": "暂无简介", "content": "```python\r\nclass Student(models.Model):\r\n    \"\"\"学生信息\"\"\"\r\n    name = models.CharField(max_length=100, verbose_name='姓名')\r\n    sex = models.BooleanField(default=1, verbose_name='性别')\r\n    age = models.IntegerField(verbose_name='年龄')\r\n    classmate = models.CharField(max_length=5, verbose_name='班级编号')\r\n    description = models.TextField(max_length=1000, verbose_name='个性签名')\r\n\r\n    class Meta:\r\n        db_table = 'tb_student'\r\n        verbose_name = '学生'\r\n        verbose_name_plural = verbose_name\r\n\r\n```\r\n\r\n\r\nPOST /students/   添加一个学生信息\r\nGET /students/   获取所有学生信息\r\n\r\nGET /students/<pk>  获取一个学生信息\r\nPUT /students/<pk>  更新一个学生信息\r\nDELETE /students/<pk>  删除一个学生信息\r\n\r\n一个路由对应一个视图类，所以可以把5个api分成两个类来完成\r\n\r\n## 1.get和post\r\n```python\r\npath(\"students/\",views.StudentView.as_view()),\r\n```\r\n```python\r\nclass StudentView(View):\r\n    \"\"\"学生视图\"\"\"\r\n    def post(self, request):\r\n        \"\"\"添加一个学生信息\"\"\"\r\n        # 1.接收客户端提交的数据\r\n        name = request.POST.get('name')\r\n        sex = request.POST.get('sex')\r\n        age = request.POST.get('age')\r\n        classmate = request.POST.get('classmate')\r\n        description = request.POST.get('description')\r\n        # 2.操作数据库，保存数据\r\n        instance = Student.objects.create(\r\n            name=name,\r\n            sex=sex,\r\n            age=age,\r\n            classmate=classmate,\r\n            description=description,\r\n        )\r\n        # 3.返回结果，访问405,需要postman，输入表单\r\n        return JsonResponse(data={\"id\":instance.pk,\"name\": instance.name,\"sex\": instance.sex,\"age\": instance.age,\"classmate\": instance.classmate,\"description\": instance.description,},status=201)\r\n\r\n    def get(self,request):\r\n        \"\"\"获取多个学生信息\"\"\"\r\n        #1.读取数据库\r\n        students_list=list(Student.objects.values())\r\n        # print(students_list)\r\n        #2.返回数据\r\n        return JsonResponse(data=students_list,status=200,safe=False)  #In order to allow non-dict objects to be serialized set the safe parameter to False. 解决：safe=False\r\n```\r\n## 2.get,put,delete\r\n```python\r\nre_path(\"students/(?P<pk>\\d+)/$\",views.StudentInfoView.as_view()),\r\n```\r\n```python\r\nclass StudentInfoView(View):\r\n    def get(self,request,pk):\r\n        \"\"\"获取一条数据\"\"\"\r\n        try:\r\n            instance=Student.objects.get(pk=pk)\r\n            return JsonResponse(data={\"id\":instance.pk,\"name\": instance.name,\"sex\": instance.sex,\"age\": instance.age,\"classmate\": instance.classmate,\"description\": instance.description,},status=200)\r\n        except Student.DoesNotExist:\r\n            return JsonResponse(data=None,status=404) #没有内容\r\n\t#下面错误写法\r\n    def put(self,request,pk):\r\n        \"\"\"更新一个学生信息\"\"\"   #put不支持表单提交,\r\n        name = request.POST.get('name')\r\n        print(f\"name={request.body}\")  #使用格式化字符串打印\r\n        sex = request.POST.get('sex')\r\n        age = request.POST.get('age')\r\n        classmate = request.POST.get('classmate')\r\n        description = request.POST.get('description')\r\n        # 2.操作数据库，保存数据\r\n        try:\r\n            instance = Student.objects.get(pk=pk)\r\n            instance.name=name\r\n            instance.sex=sex\r\n            instance.age=age\r\n            instance.classmate=classmate\r\n            instance.description=description\r\n            instance.save()\r\n        except Student.DoesNotExist:\r\n            return JsonResponse(data=None,status=404) #没有内容\r\n        # 3.返回结果，访问405,需要postman，输入表单\r\n        return JsonResponse(data={\r\n            \"id\":instance.pk,\r\n            \"name\": instance.name,\r\n            \"sex\": instance.sex,\r\n            \"age\": instance.age,\r\n            \"classmate\": instance.classmate,\r\n            \"description\": instance.description,\r\n        },status=201)\r\n```\r\n## 上面使用postman实现模拟提交，发现put不能用表单，接收不到数据，只能raw-json\r\n如下：\r\n```python\r\n    def put(self, request, pk):\r\n        \"\"\"更新一个学生信息\"\"\"\r\n        # \"\"\"\r\n        # #错误写法   #put不支持表单提交\r\n        # name = request.POST.get('name')\r\n        # print(f\"name={request.body}\")  #使用格式化字符串打印\r\n        # sex = request.POST.get('sex')\r\n        # age = request.POST.get('age')\r\n        # classmate = request.POST.get('classmate')\r\n        # description = request.POST.get('description')\r\n        # \"\"\"\r\n        # 1.接收数据\r\n        data = json.loads(request.body)  # 前端使用ajax发送json数据\r\n        # print(f\"data={data}\")\r\n        # alt+鼠标左键垂直,或者alt+j\r\n        name = data.get('name')\r\n        sex = data.get('sex')\r\n        age = data.get('age')\r\n        classmate = data.get('classmate')\r\n        description = data.get('description')\r\n        # 2.操作数据库，保存数据\r\n        try:\r\n            instance = Student.objects.get(pk=pk)\r\n            instance.name = name\r\n            instance.sex = sex\r\n            instance.age = age\r\n            instance.classmate = classmate\r\n            instance.description = description\r\n            instance.save()\r\n        except Student.DoesNotExist:\r\n            return JsonResponse(data={}, status=404)  # 没有内容\r\n        # 3.返回结果，访问405,需要postman，输入表单\r\n        return JsonResponse(data={\r\n            \"id\": instance.pk,\r\n            \"name\": instance.name,\r\n            \"sex\": instance.sex,\r\n            \"age\": instance.age,\r\n            \"classmate\": instance.classmate,\r\n            \"description\": instance.description,\r\n        }, status=201)\r\n\r\n    def delete(self, request, pk):\r\n        \"\"\"删除一个学生信息\"\"\"\r\n        try:\r\n            Student.objects.filter(pk=pk).delete()\r\n        except:\r\n            pass\r\n        return JsonResponse(data={}, status=204)\r\n```\r\n注意如果data部署dict，需要safe=False\r\n否则# In order to allow non-dict objects to be serialized set the safe parameter to False.\r\npostman:\r\n![](/media/editor\\屏幕截图 2022-07-30 034518_20220730034602900011.jpg)", "note_img": "uploads/blog/blog.jpeg", "create_time": "2022-07-30T02:04:41.628", "update_time": "2022-07-30T06:24:23.367", "click_num": 0, "love_num": 0, "user": 10}}, {"model": "blog.note", "pk": 26, "fields": {"title": "django配置mysql", "desc": "暂无简介", "content": "如果mysql版本<8.0，需要在pro的————init.py添加如下\r\n```python\r\nfrom pymysql import install_as_MySQLdb\r\n\r\ninstall_as_MySQLdb()\r\n```\r\n或者\r\n```python\r\nimport pymysql\r\npymysql.install_as_MySQLdb()\r\n```", "note_img": "uploads/blog/blog.jpeg", "create_time": "2022-07-30T03:37:23.299", "update_time": "2022-07-30T03:37:23.299", "click_num": 0, "love_num": 0, "user": 10}}, {"model": "blog.note", "pk": 27, "fields": {"title": "解决tag多出“”的bug", "desc": "暂无简介", "content": "from taggit.managers import TaggableManager\r\n使用django-taggit\r\n遇到个bug:\r\n![](/media/editor\\屏幕截图 2022-07-30 071958_20220730072108085748.jpg)\r\n每次都会添加个“”。。。\r\n```python\r\ndef get(request):\r\nnote_post_form.fields['tags'].initial=article.tags.all() \r\n```\r\n发现一个bug,这里每次初始化会自动多出来\"\",所以上面post创建时候需要eval()过滤掉字符串的“”\r\n\r\n```python\r\ntags_post=request.POST['tags'] #拿到的是带,的字符串\r\n            print(type(tags_post))\r\n            tags_list_post=tags_post.split(',')  #分割为list\r\n            tags_list=[]\r\n            for i in tags_list_post:\r\n                try:\r\n                    i=eval(i)  #去除每个tag的\"\"  #这里是处理tag初始化表单时自动加上“”的bug\r\n                except:\r\n                    pass\r\n                tags_list.append(i)\r\n            # print(tags_list)\r\n            try:\r\n                # https://blog.csdn.net/alexander068/article/details/119724017\r\n                #Django多对多数据增删改查 http: // t.zoukankan.com / 17vv - p - 11723372.html\r\n                article.tags.set(tags_list) #注意参数是个标签组成的列表\r\n\t\t\t\tarticle.save()\r\n\t\t\t\treturn Httpresponse('TAG')\r\n\t\t\texcept:\r\n\t\t\t\treturn Httpresponse('tagflase')\r\n```\r\n", "note_img": "uploads/blog/blog.jpeg", "create_time": "2022-07-30T06:35:57.251", "update_time": "2022-08-04T18:29:09.608", "click_num": 0, "love_num": 0, "user": 10}}, {"model": "blog.note", "pk": 28, "fields": {"title": "django使用drf", "desc": "暂无简介", "content": "这是使用drf的reetfulapi\r\n我的另一个django原生drf；/blog/detail/25相比\r\n更加简洁方便\r\n\r\n#1.新建序列化器serializers.py\r\n```python\r\nfrom rest_framework import serializers\r\nfrom stu_api.models import Student\r\n\r\n#创建序列化器类，回头会在视图中被调用，用于序列化与反序列化\r\nclass StudentModelSerializer(serializers.ModelSerializer):\r\n    class Meta:\r\n        model=Student\r\n        fields=\"__all__\"  #决定序列化里给客户端提供的字段，all代表所有\r\n        # fields=[\"id\",\"name\"] #只给两个\r\n\r\n```\r\n#2.视图\r\n```python\r\nfrom rest_framework.viewsets import ModelViewSet\r\nfrom stu_api.models import Student\r\nfrom .serializers import StudentModelSerializer\r\n\r\n\r\n# Create your views here.\r\n\r\nclass StudentModelViewSet(ModelViewSet):\r\n    queryset = Student.objects.all()\r\n    serializer_class = StudentModelSerializer\r\n```\r\n#3.路由\r\n主路由添加\r\n```python\r\npath('api/', include('students.urls')), #/api可以到drf的界面\r\n```\r\n子路由：\r\n```python\r\nfrom rest_framework.routers import DefaultRouter\r\nfrom . import views\r\n\r\nrouter = DefaultRouter()\r\nrouter.register(\"students2\", views.StudentModelViewSet, basename=\"students2\")  # 有几个写几个\r\n\r\n#路由列表\r\nurlpatterns = [\r\n\r\n] + router.urls\r\n```\r\n\r\n4.访问：\r\n![](/media/editor\\屏幕截图 2022-07-30 085456_20220730085519880433.jpg)\r\n可以点击里面的路由\r\n![](/media/editor\\屏幕截图 2022-07-30 085608_20220730085622651740.jpg)\r\n后面可以在路由后加ip,跳转到对应的\r\n![](/media/editor\\屏幕截图 2022-07-30 085716_20220730085731058340.jpg)\r\n还可以点击右上角进行删除", "note_img": "uploads/blog/blog.jpeg", "create_time": "2022-07-30T08:58:41.342", "update_time": "2022-07-30T08:58:41.342", "click_num": 0, "love_num": 0, "user": 10}}, {"model": "blog.note", "pk": 29, "fields": {"title": "conda下pip", "desc": "暂无简介", "content": "conda下和pip如果有同名包，\r\n可能导致一直包的依赖冲突以及引入错误等\r\nThe environment is inconsistent, please check the package plan carefully The following packages are causing the inconsistency", "note_img": "uploads/blog/blog.jpeg", "create_time": "2022-08-04T00:15:47.755", "update_time": "2022-08-04T00:20:29.835", "click_num": 0, "love_num": 0, "user": 10}}, {"model": "blog.note", "pk": 30, "fields": {"title": "nginx和apache部署django", "desc": "暂无简介", "content": "本博客的html,js,css等静态文件部署，不分离\r\nnginx的conf\r\n```objective-c\r\nlocation / {\r\n            #root   html;\r\n            #index  index.html index.htm;\r\n            root F:/pythonpic52projects/52projects/berryha_blog/mysite/templates;\r\n            proxy_pass http://127.0.0.1:8002; #nginx代理到apache服务的8002端口\r\n            proxy_connect_timeout       900;\r\n            proxy_send_timeout          900;\r\n            proxy_read_timeout          900;\r\n            send_timeout                900;\r\n            client_max_body_size 3000m;\r\n        }\r\n         # 主要是加入下面三行(发现其实nginx和apache这里只要有一个配置了就行)\r\n        location /static/ {\r\n            root F:;\t\t\t\t# 此处为Django中设置的STATIC_ROOT对应位置（去掉static,否则404）\r\n        }\r\n\r\n        location /media/ {\r\n            root F:/pythonpic52projects/52projects/berryha_blog/mysite/; #此处为Django中设置的mediaroot位置\r\n        }\r\n```\r\n此时：\r\napache也可以选择是否带上静态文件:\r\n```objective-c\r\n#这是前端配置 ，前后端不分离，就带上下方的；如果前后端分离，apache部署后端，nginx部署前端就不带下方的,当然可以都带，防止一个没了\r\n#ProxyPass /nginx/ http://localhost/media/\r\n#ProxyPassReverse /nginx/ http://localhost/media/\r\n\r\n#项目静态文件STATIC_ROOT  collect得到的\r\n#alias后面的/static意思是当客户端（浏览器）发送的请求uri里面匹配到static时会指向到\r\n#Alias /static/ /path/to/mysite.com/static/\r\n#<Directory /path/to/mysite.com/static>\r\n#Require all granted\r\n#</Directory>\r\n#Alias /static/ F:/static/\r\n#<Directory F:/static>\r\n#  AllowOverride None\r\n#  Options None\r\n#  Require all granted\r\n#</Directory>\r\n\r\n#media目录\r\n#Alias /media/ /path/to/mysite.com/media/\r\n#<Directory /path/to/mysite.com/media>\r\n#Require all granted\r\n#</Directory>\r\n#Alias /media/ F:/pythonpic52projects/52projects/berryha_blog/mysite/media/\r\n#<Directory F:/pythonpic52projects/52projects/berryha_blog/mysite/media>\r\n#  AllowOverride None\r\n#  Options None\r\n#  Require all granted\r\n#</Directory>\r\n```", "note_img": "uploads/blog/blog.jpeg", "create_time": "2022-08-04T18:18:16.048", "update_time": "2022-08-04T18:28:40.298", "click_num": 0, "love_num": 0, "user": 10}}, {"model": "blog.note", "pk": 31, "fields": {"title": "django使用haystack来调用Elasticsearch搜索引擎", "desc": "暂无简介", "content": "bulk() got an unexpected keyword argument 'doc_type'\r\nElasticSearch 7x之后，就没有了doc_type这个参数；但haystack还是保留了\r\n\r\n解决方案：注释掉源码中：**self._get_doc_type_option(),\r\n\r\n\r\n```csharp\r\nTraceback (most recent call last):\r\n  File \"F:\\Anaconda3\\envs\\dadashopenv\\lib\\site-packages\\django\\core\\handlers\\exception.py\", line 34, in inner\r\n    response = get_response(request)\r\n  File \"F:\\Anaconda3\\envs\\dadashopenv\\lib\\site-packages\\django\\core\\handlers\\base.py\", line 115, in _get_response\r\n    response = self.process_exception_by_middleware(e, request)\r\n  File \"F:\\Anaconda3\\envs\\dadashopenv\\lib\\site-packages\\django\\core\\handlers\\base.py\", line 113, in _get_response\r\n    response = wrapped_callback(request, *callback_args, **callback_kwargs)\r\n  File \"F:\\Anaconda3\\envs\\dadashopenv\\lib\\site-packages\\django\\contrib\\admin\\options.py\", line 606, in wrapper\r\n    return self.admin_site.admin_view(view)(*args, **kwargs)\r\n  File \"F:\\Anaconda3\\envs\\dadashopenv\\lib\\site-packages\\django\\utils\\decorators.py\", line 142, in _wrapped_view\r\n    response = view_func(request, *args, **kwargs)\r\n  File \"F:\\Anaconda3\\envs\\dadashopenv\\lib\\site-packages\\django\\views\\decorators\\cache.py\", line 44, in _wrapped_view_func\r\n    response = view_func(request, *args, **kwargs)\r\n  File \"F:\\Anaconda3\\envs\\dadashopenv\\lib\\site-packages\\django\\contrib\\admin\\sites.py\", line 223, in inner\r\n    return view(request, *args, **kwargs)\r\n  File \"F:\\Anaconda3\\envs\\dadashopenv\\lib\\site-packages\\django\\contrib\\admin\\options.py\", line 1634, in add_view\r\n    return self.changeform_view(request, None, form_url, extra_context)\r\n  File \"F:\\Anaconda3\\envs\\dadashopenv\\lib\\site-packages\\django\\utils\\decorators.py\", line 45, in _wrapper\r\n    return bound_method(*args, **kwargs)\r\n  File \"F:\\Anaconda3\\envs\\dadashopenv\\lib\\site-packages\\django\\utils\\decorators.py\", line 142, in _wrapped_view\r\n    response = view_func(request, *args, **kwargs)\r\n  File \"F:\\Anaconda3\\envs\\dadashopenv\\lib\\site-packages\\django\\contrib\\admin\\options.py\", line 1522, in changeform_view\r\n    return self._changeform_view(request, object_id, form_url, extra_context)\r\n  File \"F:\\Anaconda3\\envs\\dadashopenv\\lib\\site-packages\\django\\contrib\\admin\\options.py\", line 1561, in _changeform_view\r\n    self.save_model(request, new_object, form, not add)\r\n  File \"F:\\dadashop\\goods\\admin.py\", line 87, in save_model\r\n    super().save_model(request, obj, form, change)\r\n  File \"F:\\dadashop\\goods\\admin.py\", line 15, in save_model\r\n    super().save_model(request, obj, form, change)\r\n  File \"F:\\Anaconda3\\envs\\dadashopenv\\lib\\site-packages\\django\\contrib\\admin\\options.py\", line 1088, in save_model\r\n    obj.save()\r\n  File \"F:\\Anaconda3\\envs\\dadashopenv\\lib\\site-packages\\django\\db\\models\\base.py\", line 741, in save\r\n    force_update=force_update, update_fields=update_fields)\r\n  File \"F:\\Anaconda3\\envs\\dadashopenv\\lib\\site-packages\\django\\db\\models\\base.py\", line 790, in save_base\r\n    update_fields=update_fields, raw=raw, using=using,\r\n  File \"F:\\Anaconda3\\envs\\dadashopenv\\lib\\site-packages\\django\\dispatch\\dispatcher.py\", line 175, in send\r\n    for receiver in self._live_receivers(sender)\r\n  File \"F:\\Anaconda3\\envs\\dadashopenv\\lib\\site-packages\\django\\dispatch\\dispatcher.py\", line 175, in <listcomp>\r\n    for receiver in self._live_receivers(sender)\r\n  File \"F:\\Anaconda3\\envs\\dadashopenv\\lib\\site-packages\\haystack\\signals.py\", line 49, in handle_save\r\n    index.update_object(instance, using=using)\r\n  File \"F:\\Anaconda3\\envs\\dadashopenv\\lib\\site-packages\\haystack\\indexes.py\", line 324, in update_object\r\n    backend.update(self, [instance])\r\n  File \"F:\\Anaconda3\\envs\\dadashopenv\\lib\\site-packages\\haystack\\backends\\elasticsearch_backend.py\", line 243, in update\r\n    **self._get_doc_type_option(),\r\n  File \"F:\\Anaconda3\\envs\\dadashopenv\\lib\\site-packages\\elasticsearch\\helpers\\actions.py\", line 525, in bulk\r\n    client, actions, ignore_status=ignore_status, *args, **kwargs  # type: ignore[misc]\r\n  File \"F:\\Anaconda3\\envs\\dadashopenv\\lib\\site-packages\\elasticsearch\\helpers\\actions.py\", line 448, in streaming_bulk\r\n    **kwargs,\r\n  File \"F:\\Anaconda3\\envs\\dadashopenv\\lib\\site-packages\\elasticsearch\\helpers\\actions.py\", line 339, in _process_bulk_chunk\r\n    resp = client.bulk(*args, operations=bulk_actions, **kwargs)  # type: ignore[arg-type]\r\n  File \"F:\\Anaconda3\\envs\\dadashopenv\\lib\\site-packages\\elasticsearch\\_sync\\client\\utils.py\", line 414, in wrapped\r\n    return api(*args, **kwargs)\r\nTypeError: bulk() got an unexpected keyword argument 'doc_type'\r\n[06/Aug/2022 15:48:51] \"POST /admin/goods/sku/add/ HTTP/1.1\" 500 190999\r\n\r\n```", "note_img": "uploads/blog/blog.jpeg", "create_time": "2022-08-06T15:55:03.733", "update_time": "2022-08-06T15:55:03.733", "click_num": 0, "love_num": 0, "user": 10}}]